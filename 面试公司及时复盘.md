## 面试公司及时复盘

一、中科合讯（北京，军工外包） 02.26    15-25k

**1.面试官稍微介绍一下公司（军工外包项目）**

**2.自我介绍**

**3.Qt的信号和槽和Qt的事件有什么区别？**

​	Qt中的信号和槽是用于**对象间通信的机制**，而事件则是用于**处理用户输入和系统事件的机制**。

​	信号和槽：1.信号和槽是Qt中一种灵活的机制，用于实现对象之间的通信。一个对象可以发射信号，而其他对象可以连接这个信号并在接收到信号时执行相应的槽函数。

2.信号和槽是完全异步的，发送信号的对象不需要等待槽函数执行完成，从而实现了对象之间的解耦。

3.信号和槽是Qt的一个重要特性，可以跨线程使用，非常适合实现用户界面响应和事件处理等功能。

​	事件：1.事件是Qt中另一个重要的机制，用于处理用户输入（如鼠标点击、键盘输入）以及系统事件（如定时器事件、窗口事件等）。

2.Qt中的事件是基于事件循环机制的，当事件发生时，Qt会将事件发送给指定的对象，并由该对象的事件处理函数进行处理。

3.事件处理是同步的，即事件发生后，事件处理函数会立即执行，直到事件处理完成才会返回。

**4.Qt信号和槽的连接有几种方式？哪几种？**

​	**4种。**

​	1.使用SIGNAL和SLOT宏连接信号与槽。

```cpp
QPushButton* button = new QPushButton("Click Me");
connect(button, SIGNAL(clicked()), this, SLOT(onButtonClicked()));
```

​	2.使用lambda表达式连接信号和槽。

```cpp
QSlider* slider = new QSlider();
connect(slider, SIGNAL(valueChanged(int)), [=](int value) {
    // 处理滑块值改变的逻辑
});
```

​	3.使用Qt5的新语法连接信号和槽，使用指针函数的地址作为参数，可以在编译时进行类型检查。

```cpp
QAction* action = new QAction("Open", this);
connect(action, &QAction::triggered, this, &MainWindow::onOpenClicked);
```

​	4.使用自定义信号和槽函数，在适当的时机通过 emit 关键字触发信号。

```cpp
// 自定义信号的声明
signals:
    void myCustomSignal(int value);

// 自定义槽函数的声明
public slots:
    void myCustomSlot(int value);

// 在适当的位置触发信号
emit myCustomSignal(42);

// 连接自定义信号与槽函数
connect(senderObject, SIGNAL(myCustomSignal(int)), receiverObject, SLOT(myCustomSlot(int)));
```

**5.QGraphicsView 用过没有？（场景，视图，和图元）。**

​	它是 Qt 中用于显示图形项（Graphics Items）的视图类。QGraphicsView 是一个用于显示 QGraphicsScene 中图形项的可视化部件，可以在其中显示和交互多个图形项，如文本、图像、矩形、椭圆等。

**6.Qt的事件过滤你知道嘛？了解吗？事件过滤的作用？**

​	事件过滤的作用：是一种机制，允许你在特定对象上拦截和处理事件，而不修改原始对象的代码。事件过滤器可以用于捕获、过滤和处理各种事件，包括键盘事件、鼠标事件、定时器事件等。

1.扩展事件处理能力：通过事件过滤器，你可以在一个对象上添加额外的事件处理逻辑，而无需修改原始对象的代码。这样可以扩展对象的事件处理能力，实现更复杂的交互逻辑或功能。

2.事件过滤和拦截：事件过滤器可以拦截某个对象接收到的事件，进行自定义处理，然后决定是否将事件传递给原始对象继续处理。这样可以在事件传递过程中进行干预，实现事件的过滤和拦截，例如屏蔽某些特定的事件或修改事件的属性。

3.动态事件处理：事件过滤器可以动态地选择性地处理事件，根据事件的具体属性或上下文来决定是否处理。这样可以根据需要对事件进行条件处理，灵活地控制事件的处理逻辑。

4.对象间通信：通过事件过滤器，你可以在不同对象之间实现事件的传递和通信。例如，你可以将一个事件过滤器安装在父级对象上，拦截子对象的事件并进行处理，实现对象间的消息传递和交互。

**7.你平时在用Qt的时候用了哪些东西？哪些技术？**

1. **界面设计与布局**：使用Qt Designer设计界面，利用Qt的布局管理器（如QVBoxLayout、QHBoxLayout、QGridLayout等）来实现界面布局，确保界面在不同平台和分辨率下都能正确显示。
2. **信号与槽机制**：利用Qt的信号与槽机制实现对象之间的通信和交互，让不同部件之间能够响应事件、更新数据，并实现模块之间的解耦。
3. **网络编程**：使用Qt的网络模块（如QTcpSocket、QUdpSocket、QNetworkAccessManager等）进行网络编程，实现与服务器的数据通讯、HTTP请求等功能。
4. 数据库操作：通过Qt的SQL模块连接各种数据库（如SQLite、MySQL等），执行SQL查询、插入、更新、删除等操作，实现数据的持久化存储和管理。
5. 多线程编程：利用Qt的多线程模块（如QThread、QtConcurrent等）实现多线程编程，提高程序的并发性能，避免阻塞主线程。
6. **文件操作**：使用Qt的文件操作类（如QFile、QDir等）进行文件读写、目录操作，实现文件的读取、保存、导出等功能。
7. **定时器与事件处理**：利用Qt的定时器类（如QTimer）实现定时任务，处理定时事件；同时结合事件过滤器等机制，对用户输入和系统事件进行处理。
8. **跨平台开发**：利用Qt的跨平台性，编写一套代码可以在不同操作系统（如Windows、macOS、Linux等）上运行，减少开发和维护成本。

**8.Qt读写xml,用过几种方式？**

​	三种。

1.QXmlStreamReader：一种快速的基于流的方式访问良格式 XML 文档，特别适合于实现一次解析器（所谓“一次解析器”，可以理解成我们只需读取文档一次，然后像一个遍历器从头到尾一次性处理 XML 文档，期间不会有反复的情况，也就是不会读完第一个标签，然后读第二个，读完第二个又返回去读第一个，这是不允许的）；

2.DOM（Document Object Model）：将整个 XML 文档读入内存，构建成一个树结构，允许程序在树结构上向前向后移动导航，这是与另外两种方式最大的区别，也就是允许实现多次解析器（对应于前面所说的一次解析器）。DOM 方式带来的问题是需要一次性将整个 XML 文档读入内存，因此会占用很大内存.

3.SAX（Simple API for XML）：提供大量虚函数，以事件的形式处理 XML 文档。这种解析办法主要是由于历史原因提出的，为了解决 DOM 的内存占用提出的（在现代计算机上，这个一般已经不是问题了）。

**9.QDomDocument,几个类的关系是怎么样的？**

​	`QDomDocument` 类是用于处理XML文档的核心类，它提供了创建、操作和解析XML文档的功能。

1.**QDomNode**：`QDomNode` 是 XML 文档中节点的基类，它可以代表文档、元素、属性、文本等不同类型的节点。`QDomNode` 提供了访问节点的方法和属性，以及节点之间的关系。

2.**QDomElement**：`QDomElement` 继承自 `QDomNode`，表示 XML 文档中的元素节点。`QDomElement` 包含了元素的标签名、属性、子元素等信息，可以通过它来操作和处理 XML 元素。

3.**QDomAttr**：`QDomAttr` 继承自 `QDomNode`，表示 XML 元素的属性节点。`QDomAttr` 用于表示元素的属性名称和属性值，可以通过它来获取和设置元素的属性。

4.**QDomText**：`QDomText` 继承自 `QDomNode`，表示 XML 文档中的文本节点。`QDomText` 用于表示元素内的文本内容，可以通过它来读取和修改元素的文本数据。

5.**QDomNodeList**：`QDomNodeList` 是一个节点列表类，用于存储一组节点对象。通过 `QDomNodeList` 可以方便地对节点进行遍历和访问，获取节点的数量、迭代节点等操作。

**10.Qt的绘图你用过？**

1. **QWidget**：QWidget 是Qt中所有用户界面对象的基类，也是绘图的基础。你可以通过重写 QWidget 的 `paintEvent` 函数，在其中使用 QPainter 进行绘图操作。
2. **QPainter**：QPainter 是Qt提供的2D绘图引擎，用于在QWidget或QPixmap等设备上进行绘图操作。你可以使用 QPainter 绘制各种几何图形（如直线、矩形、椭圆等）、文本、图像等。
3. **QPaintDevice**：QPaintDevice 是绘图设备的基类，它可以是QWidget、QPixmap、QImage等。通过继承 QPaintDevice，你可以创建自定义的绘图设备，实现离屏渲染等功能。
4. **QPen** 和 **QBrush**：QPen 用于定义绘制线条的样式（如颜色、宽度、风格），而 QBrush 用于定义填充区域的样式（如颜色、填充模式）。在绘制图形时，通过设置 QPen 和 QBrush 可以实现不同的效果。

**11.Qt的模式和视图有什么好处（MVC）？**

​	模式（Model）和视图（View）是一种常用的设计模式，它将数据和用户界面分离开来，使得数据和界面之间的交互变得更加灵活和可扩展。(C: control 控制)。

1.**分离数据和UI**：模式和视图将数据和用户界面分离开来，使得数据的存储、处理、显示等操作与UI的布局、控件等操作相互独立。这种分离有助于代码的可维护性和重用性，使得程序的架构更加清晰和易于扩展。

2.**支持多种数据源**：模式和视图允许使用不同的数据源（如数据库、XML文档、JSON文件等）来填充数据模型，从而可以更方便地处理和显示数据。数据源可以通过模型接口（如QAbstractItemModel）来实现，而视图则通过代理对象（如QStyledItemDelegate）来控制数据的显示和编辑。

3.**提供灵活的数据呈现方式**：Qt的模式和视图提供了丰富的数据呈现方式，包括列表、树形、表格、图形等多种视图类型。用户可以根据实际需求选择适合的视图类型，以获得最佳的数据呈现效果。

4.**支持数据排序和过滤**：Qt的模式和视图支持数据的排序和过滤，可以按照任意列进行升序或降序排序，也可以根据用户输入的筛选条件过滤数据。这种功能使得用户可以更方便地浏览和管理大量的数据。

5.**支持数据编辑和更新**：Qt的模式和视图支持数据的编辑和更新，用户可以通过界面控件来修改数据并将其保存到数据源中。这种功能使得程序更加灵活和交互性强，同时也提高了用户的工作效率。

**12.你知道基类的析构函数为什么声明为虚的吗？（virtual）**

​	这是因为当我们使用指向派生类对象的基类指针或引用时，如果基类的析构函数不是虚函数，那么在delete一个指向派生类对象的基类指针时，只会调用基类的析构函数，而不会调用派生类的析构函数，导致派生类的资源无法被正确地释放，从而可能导致内存泄漏或其他错误。

​	而通过将基类的析构函数声明为虚函数，C++编译器就能够在运行时确定所指向的实际对象类型，并自动调用该对象类型对应的析构函数，从而保证了对象的正确释放。因此，在使用C++多态时，通常都需要将基类的析构函数声明为虚函数，以确保正确的析构行为。

**13.C++里面，对多态的理解？**

多态：它使得程序能够更加灵活、可扩展和易于维护。

在C++中，多态体现在两个方面，运行时多态和编译时多态。

1.运行时多态（动态多态）

运行时多态是指在程序运行时根据对象的实际类型来确定调用哪个函数的机制。在C++中，通过使用**虚函数**和**基类指针或引用**，可以实现运行时多态。

具体来说，当我们使用基类指针或引用来调用虚函数时，如果该指针或引用指向了派生类对象，那么程序就会自动调用派生类中对应的虚函数，而不是基类中的函数。这种机制可以让程序更加灵活和可扩展，因为我们可以在派生类中覆盖（override）基类的虚函数，从而实现不同的行为。****

2.编译时多态（静态多态）

编译时多态是指在程序编译时就可以确定调用哪个函数的机制。在C++中，编译时多态主要体现在**函数重载**和**模板**的使用上。

函数重载允许我们定义多个**同名函数**，但它们的**参数列表不同**，从而可以根据函数的参数类型和数量来确定调用哪个函数。这种机制可以让程序更加灵活和易于维护，因为我们可以用相同的函数名来表示不同的行为。

模板是一种通用编程技术，它允许我们定义一组可以适用于不同数据类型的函数或类。通过使用模板参数，我们可以在编译时生成多个不同的函数或类，从而实现编译时多态。

**14.Linux操作系统你用过吗？**

​	常用的快捷键

**15.你大概什么能到岗？**

**16.你期望薪资？**

**17.反问？**

​	1.问了对我的建议 2.问了有没有人带。

对我的建议：多看，多练，多写，多思考，多总结，不要怕犯错。数据结构和算法，设计模式都没问。问题：知其然不知其所以然。封装String类。封装，继承，多态，抽象？ 时间对程序员是最重要的，每天多学1-2个小时。

不要依靠师傅带，要靠自己，要独立。自己要锻炼，自己要成长。讲业务，业务可以带，程序上不要想着别人带。



二、北京国遥新天地（军工外包）	0301			20-21k

​	**1.自我介绍**

​	**2.你一直在用QT吗？还用过其他的什么吗？**

​		2.1 qt界面一共两大块 我们用的qWidgets，QML没用。

​		2.2 还用过Boost库，智能指针shared_ptr,用于管理动态内存，避免内存泄漏和悬空指针问题。	

​		2.3 STL库。vector（动态数组），list（双向链表），deque(双端队列)，map（键唯一，值对应键），set（插入的元素不重复）

​	**3.你这边用QT相关的技术有哪些？**

1. **界面设计与布局**：使用Qt Designer设计界面，利用Qt的布局管理器（如QVBoxLayout、QHBoxLayout、QGridLayout等）来实现界面布局，确保界面在不同平台和分辨率下都能正确显示。

2. **信号与槽机制**：利用Qt的信号与槽机制实现对象之间的通信和交互，让不同部件之间能够响应事件、更新数据，并实现模块之间的解耦。

3. **网络编程**：使用Qt的网络模块（如QTcpSocket、QUdpSocket、**QNetworkAccessManager**等）进行网络编程，实现与服务器的数据通讯、HTTP请求等功能。

4. **数据库操作**：通过Qt的SQL模块连接各种数据库（如SQLite、MySQL等），执行SQL查询、插入、更新、删除等操作，实现数据的持久化存储和管理。

   4.1查询：**SELECT** column1, column2, ... **FROM** table_name **WHERE** condition;举例：SELECT * FROM customers WHERE city = 'Beijing';

   4.2 插入：I**NSERT INTO** table_name (column1, column2, ...) **VALUES** (value1, value2, ...);举例：INSERT INTO customers (name, city, age) VALUES ('John', 'Shanghai', 30);

   4.3更新：**UPDATE** table_name **SET** column1 = value1, column2 = value2, ... **WHERE** condition;举例：UPDATE customers SET city = 'Beijing' WHERE id = 1;

   4.4删除：**DELETE FROM** table_name **WHERE condition**;举例：DELETE FROM customers WHERE id = 1;

5. **多线程编程**：利用Qt的多线程模块（如QThread、QtConcurrent等）实现多线程编程，提高程序的并发性能，避免阻塞主线程。

6. **文件操作**：使用Qt的文件操作类（如QFile、QDir等）进行文件读写、目录操作，实现文件的读取、保存、导出等功能。

7. **定时器与事件处理**：利用Qt的定时器类（如QTimer）实现定时任务，处理定时事件；同时结合事件过滤器等机制，对用户输入和系统事件进行处理。

8. **跨平台开发**：利用Qt的跨平台性，编写一套代码可以在不同操作系统（如Windows、macOS、Linux等）上运行，减少开发和维护成本。

​	**4.多线程有使用过吗？**

​		有的。在 Qt 中进行多线程编程可以使用 `QThread` 类来创建和管理线程，同时也可以利用**信号与槽**机制来实现线程间的通信。

##### 	多线程使用方法

1. **继承 QThread 类**：创建一个新的类并继承自 `QThread`，重写 `run()` 方法，在 `run()` 方法内编写线程要执行的代码。

   示例代码：

   \#include <QThread> 

   #include <QDebug> 

   class MyThread : public QThread 

   { 

   ​	public:    void run() override

   ​	 {        

   ​			for (int i = 0; i < 5; ++i) 

   ​			{            qDebug() << "Thread running" << i;            sleep(1); *// 模拟耗时操作*        			}   

    	}

    };

   int main(int argc, char *argv[])

    {    

   ​		QCoreApplication a(argc, argv);     

   ​		MyThread thread;    

   ​		thread.start();    

   ​		 return a.exec(); 

   }

2. **使用 QObject 的子类**：创建一个继承自 `QObject` 的子类，将耗时操作封装在该类中的槽函数中，然后使用 `moveToThread()` 将该对象移动到新创建的线程中。

   示例代码：

   \#include <QCoreApplication> 

   #include <QThread> 

   #include <QDebug>

   class Worker : public QObject 

   {    

   ​	Q_OBJECT 

   ​	public slots:    void doWork() 

   ​	{        

   ​			for (int i = 0; i < 5; ++i)

   ​			 {            

   ​				qDebug() << "Worker running" << i;            

   ​					QThread::sleep(1); *// 模拟耗时操作*       

   ​			 }       

   ​			 emit workFinished();    

   ​	} 

   ​	signals:    void workFinished();

    };

   int main(int argc, char *argv[]) 

   {    

   ​	QCoreApplication a(argc, argv);     

   ​	QThread workerThread;    

   ​	Worker worker;    

   ​	worker.moveToThread(&workerThread);        

   ​	QObject::connect(&workerThread, &QThread::started, &worker, &Worker::doWork);    

   ​	QObject::connect(&worker, &Worker::workFinished, &workerThread, &QThread::quit);     

   ​	workerThread.start();    

   ​	return a.exec(); 

   }

3. **信号与槽机制**：通过信号与槽机制实现线程间的通信，比如在线程完成任务时发出信号通知主线程。

​	**5.Linux系统有使用过吗？做过开发吗？国产化的系统有使用过吗？**

​			有。有用过虚拟机开发g++.

​			没有，有了解几个国产化系统：中标麒麟，银河麒麟操作系统，深度Linux。

​	**6.数据库有使用过吗？Oracle有用过吗？**

​		有的。MySQL。

​		没有用过。Oracle是关系型数据库管理系统，依靠强大的高性能、可靠性，被广泛应用于企业级应用和大型系统中。

​	**7.界面部分的QSS用的多吗？**

​		多，略过。

​	**8.你对信号和槽的理解是怎么样的？**

​		Qt中的信号和槽是用于**对象间通信的机制**。（异步通信方式）

​		8.1**信号（Signal）**：

​		信号是Qt中特有的一种机制，用于在对象发生特定事件时通知其他对象。

​		信号由特殊的宏定义，如 `Q_SIGNALS`，声明在类的 `signals:` 部分，并没有实际的函数体。

​		当对象的状态发生变化或特定事件发生时，可以通过调用 `emit` 关键字来发射（触发）信号。

​		8.2**槽（Slot）**：

​		槽是用于接收信号的特殊成员函数，可以响应特定的信号。

​		槽函数可以是普通的成员函数，不需要使用特殊的关键字声明。

​		将槽函数与信号关联（连接）起来，当信号被发射时，槽函数会被自动调用。

**8.3信号与槽的连接**：

​		使用 `QObject::connect` 函数可以将信号与槽函数进行连接，建立对象之间的通信。

​		连接时需要指定信号源、信号、槽函数所属对象以及槽函数。

​		一个信号可以连接多个槽，一个槽也可以响应多个信号。

8.4特点和优势：

​		信号和槽机制是Qt框架的重要特性，实现了松耦合的对象间通信，使代码更加灵活和可维护。

​		支持跨线程的信号和槽连接，方便在多线程应用程序中实现对象间的异步通信。

​		可以自定义信号和槽，实现自定义事件的处理和传递。

​	**9.软件程序运行起来比较耗时，怎么处理？有什么手段？**

​				两种方式，第一种用多线程，后台加载数据，界面行运行起来，第二种就是通过事件机制，先将事件发送出去，放到事件队列中，这样主界面不会卡顿，等到主事件循环获取控制权时，会触发事件处理。

1. **代码优化**：
   - 对程序进行性能分析，找出性能瓶颈所在的代码段。
   - 优化算法和数据结构，减少不必要的计算或内存开销。
   - 避免过多的循环嵌套和递归调用，尽量减少函数调用开销。
2. **并行处理**：
   - 使用多线程或并发处理，将耗时的任务分解成多个子任务并行执行，以提高整体处理速度。
   - 合理利用CPU的多核资源，将不同任务分配给不同的核心并行处理。
3. **延迟加载**：
   - 将程序启动时不必要的资源加载延迟到实际需要时再加载，以减少启动时间。
   - 可以采用惰性加载的方式，只在需要时才初始化和加载相关资源。
4. **界面优化**
   - 采取渐进式加载的方式，先显示核心内容，然后再加载其他部分内容，以提高用户看到界面的速度。
   - 避免在界面加载时执行耗时操作，如网络请求、数据库查询等，可以采用异步方式完成这些操作。

5.**缓存机制**：

- 使用缓存技术来存储计算结果或频繁访问的数据，避免重复计算或I/O操作。

6.**性能测试和监控**：

- 进行系统负载测试和性能测试，找出系统瓶颈和性能瓶颈，并及时优化。
- 实时监控系统运行情况，发现性能问题并及时处理。

7.**性能调试器（Performance Profiler）**：

- Visual Studio内置了性能调试器，可以对应用程序进行性能分析和剖析。
- 开发者可以使用性能调试器来检测程序中的性能瓶颈，找出耗时的函数或代码段，并优化性能。

​	**10.异步处理，你了解吗？异步处理的方法你知道有哪些吗？信号和槽也可以实现异步（了解一下怎么实现），信号和槽的第五个参数。**

​	异步处理是一种**编程模式**，允许程序在执行某个操作时不必等待其完成，而是继续执行其他任务，提高程序的响应性和效率。

​	我了解三种方式：

​	1.回调函数。

- 在异步任务完成后，通过回调函数来处理任务的结果。
- 异步任务执行完毕后，会调用预先定义好的回调函数，并将结果作为参数传递给回调函数。

​	2.Promise/Deferred

- Promise/Deferred 是一种用于异步编程的设计模式，用于处理异步任务的结果。
- 通过Promise对象表示一个尚未完成的操作，并使用then()方法指定操作完成后的处理逻辑。

​	3.异步函数（**Async/Await**）

使用async关键字定义异步函数，可以在函数内部使用await关键字等待异步操作的完成。

信号和槽异步：信号和槽机制可以用于实现异步处理。基本思想是，某个对象发出信号，其他对象通过连接到这个信号的槽函数来接收信号并进行相应的处理。由于信号和槽之间是**异步**的，所以可以实现**非阻塞**的事件处理。



​	**11.事件有接触过吗？用事件做过开发吗？用事件如何做异步处理？**

​		接触过。有。键盘、鼠标、绘图、定时器、关闭、焦点、拖放（**Drag and Drop Events**）、自定义事件。

​	Qt的事件处理是基于**事件循环**的，而事件循环本身就是一种**异步处理机制**。

​		1.**自定义事件**：在需要进行异步处理的地方，可以定义一个自定义事件，例如`CustomEvent`。

​		2.**重写事件处理函数**：在相关的Qt对象（如QWidget或QCoreApplication）中，重写`event`方法，处理自定义事件。当自定义事件发生时，会触发相应的事件处理函数。

​		3.**使用定时器**：可以创建一个定时器，在定时器的时间间隔内执行异步操作。当定时器超时时，会触发定时器事件，可以在定时器事件处理函数中执行异步操作

​	**12.你做网络主要是做了哪些工作？（问项目）**

​		自己发挥。

​	**13.数据库，你对表的优化有过了解吗？**

​		**题目：有一些数据，分别在两个表里存的，但是我要你用一个SQL语句查出来，怎么查？怎么写？**

​		了解一些：优化方式：

​		1.**合适的数据类型** （使用合适的数据类型来存储数据，避免使用过大或不必要的数据类型，以节省存储空间和提高查询速度。）

​		2.**索引优化**（为经常用于检索的列创建索引，可以加快查询速度。避免创建过多索引，因为每个索引都会占用额外的空间并影响写入性能。） 

​		3.**查询优化**（编写高效的SQL查询语句，避免使用SELECT * 和不必要的JOIN操作。使用EXPLAIN语句来分析查询执行计划，优化慢查询。）

​		 4.**适当的缓存设置**（合理设置查询缓存、查询缓存大小等参数，可以减少数据库访问次数，提高性能。）



​	题目解答：可以使用**INNER JOIN**语句连接两个表。示例：

​	**SELECT** table1.height, table2.weight 

​	**FROM** table1

​	**INNER JOIN** table2 **ON** table1.name = table2.name 

​	**WHERE** table1.name = '小明';



​	**14.你会给其他人介绍一些技术，主要是哪方向？主要有哪些呢?**

​		自由发挥。

​	**15.你对薪资的需求？**

​	**16.介绍公司环境，办公环境。**

​	**17.多久能入职？**

​	**18.反问？**

​	1.问了对我这次面试的建议 2.问了薪酬结构，公积金缴纳基数和比例，年终奖，单双休。

建议：掌握比较单一，用国产系统做开发，需要在Linux系统下做开发。多线程，异步处理需要了解。



三、北京踏歌智行科技有限公司	  0306	15-23k