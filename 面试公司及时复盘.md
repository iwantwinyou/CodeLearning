## 面试公司及时复盘

一、中科合讯（北京，军工外包） 02.26    15-25k

**1.面试官稍微介绍一下公司（军工外包项目）**

**2.自我介绍**

**3.Qt的信号和槽和Qt的事件有什么区别？**

​	Qt中的信号和槽是用于**对象间通信的机制**，而事件则是用于**处理用户输入和系统事件的机制**。

​	信号和槽：1.信号和槽是Qt中一种灵活的机制，用于实现对象之间的通信。一个对象可以发射信号，而其他对象可以连接这个信号并在接收到信号时执行相应的槽函数。

2.信号和槽是完全异步的，发送信号的对象不需要等待槽函数执行完成，从而实现了对象之间的解耦。

3.信号和槽是Qt的一个重要特性，可以跨线程使用，非常适合实现用户界面响应和事件处理等功能。

​	事件：1.事件是Qt中另一个重要的机制，用于处理用户输入（如鼠标点击、键盘输入）以及系统事件（如定时器事件、窗口事件等）。

2.Qt中的事件是基于事件循环机制的，当事件发生时，Qt会将事件发送给指定的对象，并由该对象的事件处理函数进行处理。

3.事件处理是同步的，即事件发生后，事件处理函数会立即执行，直到事件处理完成才会返回。

**4.Qt信号和槽的连接有几种方式？哪几种？**

​	**4种。**

​	1.使用SIGNAL和SLOT宏连接信号与槽。

```cpp
QPushButton* button = new QPushButton("Click Me");
connect(button, SIGNAL(clicked()), this, SLOT(onButtonClicked()));
```

​	2.使用lambda表达式连接信号和槽。

```cpp
QSlider* slider = new QSlider();
connect(slider, SIGNAL(valueChanged(int)), [=](int value) {
    // 处理滑块值改变的逻辑
});
```

​	3.使用Qt5的新语法连接信号和槽，使用指针函数的地址作为参数，可以在编译时进行类型检查。

```cpp
QAction* action = new QAction("Open", this);
connect(action, &QAction::triggered, this, &MainWindow::onOpenClicked);
```

​	4.使用自定义信号和槽函数，在适当的时机通过 emit 关键字触发信号。

```cpp
// 自定义信号的声明
signals:
    void myCustomSignal(int value);

// 自定义槽函数的声明
public slots:
    void myCustomSlot(int value);

// 在适当的位置触发信号
emit myCustomSignal(42);

// 连接自定义信号与槽函数
connect(senderObject, SIGNAL(myCustomSignal(int)), receiverObject, SLOT(myCustomSlot(int)));
```

**5.QGraphicsView 用过没有？（场景，视图，和图元）。**

​	它是 Qt 中用于显示图形项（Graphics Items）的视图类。QGraphicsView 是一个用于显示 QGraphicsScene 中图形项的可视化部件，可以在其中显示和交互多个图形项，如文本、图像、矩形、椭圆等。

**6.Qt的事件过滤你知道嘛？了解吗？事件过滤的作用？**

​	事件过滤的作用：是一种机制，允许你在特定对象上拦截和处理事件，而不修改原始对象的代码。事件过滤器可以用于捕获、过滤和处理各种事件，包括键盘事件、鼠标事件、定时器事件等。

1.扩展事件处理能力：通过事件过滤器，你可以在一个对象上添加额外的事件处理逻辑，而无需修改原始对象的代码。这样可以扩展对象的事件处理能力，实现更复杂的交互逻辑或功能。

2.事件过滤和拦截：事件过滤器可以拦截某个对象接收到的事件，进行自定义处理，然后决定是否将事件传递给原始对象继续处理。这样可以在事件传递过程中进行干预，实现事件的过滤和拦截，例如屏蔽某些特定的事件或修改事件的属性。

3.动态事件处理：事件过滤器可以动态地选择性地处理事件，根据事件的具体属性或上下文来决定是否处理。这样可以根据需要对事件进行条件处理，灵活地控制事件的处理逻辑。

4.对象间通信：通过事件过滤器，你可以在不同对象之间实现事件的传递和通信。例如，你可以将一个事件过滤器安装在父级对象上，拦截子对象的事件并进行处理，实现对象间的消息传递和交互。

**7.你平时在用Qt的时候用了哪些东西？哪些技术？**

1. **界面设计与布局**：使用Qt Designer设计界面，利用Qt的布局管理器（如QVBoxLayout、QHBoxLayout、QGridLayout等）来实现界面布局，确保界面在不同平台和分辨率下都能正确显示。
2. **信号与槽机制**：利用Qt的信号与槽机制实现对象之间的通信和交互，让不同部件之间能够响应事件、更新数据，并实现模块之间的解耦。
3. **网络编程**：使用Qt的网络模块（如QTcpSocket、QUdpSocket、QNetworkAccessManager等）进行网络编程，实现与服务器的数据通讯、HTTP请求等功能。
4. 数据库操作：通过Qt的SQL模块连接各种数据库（如SQLite、MySQL等），执行SQL查询、插入、更新、删除等操作，实现数据的持久化存储和管理。
5. 多线程编程：利用Qt的多线程模块（如QThread、QtConcurrent等）实现多线程编程，提高程序的并发性能，避免阻塞主线程。
6. **文件操作**：使用Qt的文件操作类（如QFile、QDir等）进行文件读写、目录操作，实现文件的读取、保存、导出等功能。
7. **定时器与事件处理**：利用Qt的定时器类（如QTimer）实现定时任务，处理定时事件；同时结合事件过滤器等机制，对用户输入和系统事件进行处理。
8. **跨平台开发**：利用Qt的跨平台性，编写一套代码可以在不同操作系统（如Windows、macOS、Linux等）上运行，减少开发和维护成本。

**8.Qt读写xml,用过几种方式？**

​	三种。

1.QXmlStreamReader：一种快速的基于流的方式访问良格式 XML 文档，特别适合于实现一次解析器（所谓“一次解析器”，可以理解成我们只需读取文档一次，然后像一个遍历器从头到尾一次性处理 XML 文档，期间不会有反复的情况，也就是不会读完第一个标签，然后读第二个，读完第二个又返回去读第一个，这是不允许的）；

2.DOM（Document Object Model）：将整个 XML 文档读入内存，构建成一个树结构，允许程序在树结构上向前向后移动导航，这是与另外两种方式最大的区别，也就是允许实现多次解析器（对应于前面所说的一次解析器）。DOM 方式带来的问题是需要一次性将整个 XML 文档读入内存，因此会占用很大内存.

3.SAX（Simple API for XML）：提供大量虚函数，以事件的形式处理 XML 文档。这种解析办法主要是由于历史原因提出的，为了解决 DOM 的内存占用提出的（在现代计算机上，这个一般已经不是问题了）。

**9.QDomDocument,几个类的关系是怎么样的？**

​	`QDomDocument` 类是用于处理XML文档的核心类，它提供了创建、操作和解析XML文档的功能。

1.**QDomNode**：`QDomNode` 是 XML 文档中节点的基类，它可以代表文档、元素、属性、文本等不同类型的节点。`QDomNode` 提供了访问节点的方法和属性，以及节点之间的关系。

2.**QDomElement**：`QDomElement` 继承自 `QDomNode`，表示 XML 文档中的元素节点。`QDomElement` 包含了元素的标签名、属性、子元素等信息，可以通过它来操作和处理 XML 元素。

3.**QDomAttr**：`QDomAttr` 继承自 `QDomNode`，表示 XML 元素的属性节点。`QDomAttr` 用于表示元素的属性名称和属性值，可以通过它来获取和设置元素的属性。

4.**QDomText**：`QDomText` 继承自 `QDomNode`，表示 XML 文档中的文本节点。`QDomText` 用于表示元素内的文本内容，可以通过它来读取和修改元素的文本数据。

5.**QDomNodeList**：`QDomNodeList` 是一个节点列表类，用于存储一组节点对象。通过 `QDomNodeList` 可以方便地对节点进行遍历和访问，获取节点的数量、迭代节点等操作。

**10.Qt的绘图你用过？**

1. **QWidget**：QWidget 是Qt中所有用户界面对象的基类，也是绘图的基础。你可以通过重写 QWidget 的 `paintEvent` 函数，在其中使用 QPainter 进行绘图操作。
2. **QPainter**：QPainter 是Qt提供的2D绘图引擎，用于在QWidget或QPixmap等设备上进行绘图操作。你可以使用 QPainter 绘制各种几何图形（如直线、矩形、椭圆等）、文本、图像等。
3. **QPaintDevice**：QPaintDevice 是绘图设备的基类，它可以是QWidget、QPixmap、QImage等。通过继承 QPaintDevice，你可以创建自定义的绘图设备，实现离屏渲染等功能。
4. **QPen** 和 **QBrush**：QPen 用于定义绘制线条的样式（如颜色、宽度、风格），而 QBrush 用于定义填充区域的样式（如颜色、填充模式）。在绘制图形时，通过设置 QPen 和 QBrush 可以实现不同的效果。

**11.Qt的模式和视图有什么好处（MVC）？**

​	模式（Model）和视图（View）是一种常用的设计模式，它将数据和用户界面分离开来，使得数据和界面之间的交互变得更加灵活和可扩展。(C: control 控制)。

1.**分离数据和UI**：模式和视图将数据和用户界面分离开来，使得数据的存储、处理、显示等操作与UI的布局、控件等操作相互独立。这种分离有助于代码的可维护性和重用性，使得程序的架构更加清晰和易于扩展。

2.**支持多种数据源**：模式和视图允许使用不同的数据源（如数据库、XML文档、JSON文件等）来填充数据模型，从而可以更方便地处理和显示数据。数据源可以通过模型接口（如QAbstractItemModel）来实现，而视图则通过代理对象（如QStyledItemDelegate）来控制数据的显示和编辑。

3.**提供灵活的数据呈现方式**：Qt的模式和视图提供了丰富的数据呈现方式，包括列表、树形、表格、图形等多种视图类型。用户可以根据实际需求选择适合的视图类型，以获得最佳的数据呈现效果。

4.**支持数据排序和过滤**：Qt的模式和视图支持数据的排序和过滤，可以按照任意列进行升序或降序排序，也可以根据用户输入的筛选条件过滤数据。这种功能使得用户可以更方便地浏览和管理大量的数据。

5.**支持数据编辑和更新**：Qt的模式和视图支持数据的编辑和更新，用户可以通过界面控件来修改数据并将其保存到数据源中。这种功能使得程序更加灵活和交互性强，同时也提高了用户的工作效率。

**12.你知道基类的析构函数为什么声明为虚的吗？（virtual）**

​	这是因为当我们使用指向派生类对象的基类指针或引用时，如果基类的析构函数不是虚函数，那么在delete一个指向派生类对象的基类指针时，只会调用基类的析构函数，而不会调用派生类的析构函数，导致派生类的资源无法被正确地释放，从而可能导致内存泄漏或其他错误。

​	而通过将基类的析构函数声明为虚函数，C++编译器就能够在运行时确定所指向的实际对象类型，并自动调用该对象类型对应的析构函数，从而保证了对象的正确释放。因此，在使用C++多态时，通常都需要将基类的析构函数声明为虚函数，以确保正确的析构行为。

**13.C++里面，对多态的理解？**

多态：它使得程序能够更加灵活、可扩展和易于维护。

在C++中，多态体现在两个方面，运行时多态和编译时多态。

1.运行时多态（动态多态）

运行时多态是指在程序运行时根据对象的实际类型来确定调用哪个函数的机制。在C++中，通过使用**虚函数**和**基类指针或引用**，可以实现运行时多态。

具体来说，当我们使用基类指针或引用来调用虚函数时，如果该指针或引用指向了派生类对象，那么程序就会自动调用派生类中对应的虚函数，而不是基类中的函数。这种机制可以让程序更加灵活和可扩展，因为我们可以在派生类中覆盖（override）基类的虚函数，从而实现不同的行为。****

2.编译时多态（静态多态）

编译时多态是指在程序编译时就可以确定调用哪个函数的机制。在C++中，编译时多态主要体现在**函数重载**和**模板**的使用上。

函数重载允许我们定义多个**同名函数**，但它们的**参数列表不同**，从而可以根据函数的参数类型和数量来确定调用哪个函数。这种机制可以让程序更加灵活和易于维护，因为我们可以用相同的函数名来表示不同的行为。

模板是一种通用编程技术，它允许我们定义一组可以适用于不同数据类型的函数或类。通过使用模板参数，我们可以在编译时生成多个不同的函数或类，从而实现编译时多态。

**14.Linux操作系统你用过吗？**

​	常用的快捷键

**15.你大概什么能到岗？**

**16.你期望薪资？**

**17.反问？**

​	1.问了对我的建议 2.问了有没有人带。

对我的建议：多看，多练，多写，多思考，多总结，不要怕犯错。数据结构和算法，设计模式都没问。问题：知其然不知其所以然。封装String类。封装，继承，多态，抽象？ 时间对程序员是最重要的，每天多学1-2个小时。

不要依靠师傅带，要靠自己，要独立。自己要锻炼，自己要成长。讲业务，业务可以带，程序上不要想着别人带。



二、北京国遥新天地（军工外包）	0301			20-21k

​	**1.自我介绍**

​	**2.你一直在用QT吗？还用过其他的什么吗？**

​		2.1 qt界面一共两大块 我们用的qWidgets，QML没用。

​		2.2 还用过Boost库，智能指针shared_ptr,用于管理动态内存，避免内存泄漏和悬空指针问题。	

​		2.3 STL库。vector（动态数组），list（双向链表），deque(双端队列)，map（键唯一，值对应键），set（插入的元素不重复）

​	**3.你这边用QT相关的技术有哪些？**

1. **界面设计与布局**：使用Qt Designer设计界面，利用Qt的布局管理器（如QVBoxLayout、QHBoxLayout、QGridLayout等）来实现界面布局，确保界面在不同平台和分辨率下都能正确显示。

2. **信号与槽机制**：利用Qt的信号与槽机制实现对象之间的通信和交互，让不同部件之间能够响应事件、更新数据，并实现模块之间的解耦。

3. **网络编程**：使用Qt的网络模块（如QTcpSocket、QUdpSocket、**QNetworkAccessManager**等）进行网络编程，实现与服务器的数据通讯、HTTP请求等功能。

4. **数据库操作**：通过Qt的SQL模块连接各种数据库（如SQLite、MySQL等），执行SQL查询、插入、更新、删除等操作，实现数据的持久化存储和管理。

   4.1查询：**SELECT** column1, column2, ... **FROM** table_name **WHERE** condition;举例：SELECT * FROM customers WHERE city = 'Beijing';

   4.2 插入：I**NSERT INTO** table_name (column1, column2, ...) **VALUES** (value1, value2, ...);举例：INSERT INTO customers (name, city, age) VALUES ('John', 'Shanghai', 30);

   4.3更新：**UPDATE** table_name **SET** column1 = value1, column2 = value2, ... **WHERE** condition;举例：UPDATE customers SET city = 'Beijing' WHERE id = 1;

   4.4删除：**DELETE FROM** table_name **WHERE condition**;举例：DELETE FROM customers WHERE id = 1;

5. **多线程编程**：利用Qt的多线程模块（如QThread、QtConcurrent等）实现多线程编程，提高程序的并发性能，避免阻塞主线程。

6. **文件操作**：使用Qt的文件操作类（如QFile、QDir等）进行文件读写、目录操作，实现文件的读取、保存、导出等功能。

7. **定时器与事件处理**：利用Qt的定时器类（如QTimer）实现定时任务，处理定时事件；同时结合事件过滤器等机制，对用户输入和系统事件进行处理。

8. **跨平台开发**：利用Qt的跨平台性，编写一套代码可以在不同操作系统（如Windows、macOS、Linux等）上运行，减少开发和维护成本。

​	**4.多线程有使用过吗？**

​		有的。在 Qt 中进行多线程编程可以使用 `QThread` 类来创建和管理线程，同时也可以利用**信号与槽**机制来实现线程间的通信。

##### 	多线程使用方法

1. **继承 QThread 类**：创建一个新的类并继承自 `QThread`，重写 `run()` 方法，在 `run()` 方法内编写线程要执行的代码。

   示例代码：

   \#include <QThread> 

   #include <QDebug> 

   class MyThread : public QThread 

   { 

   ​	public:    void run() override

   ​	 {        

   ​			for (int i = 0; i < 5; ++i) 

   ​			{            qDebug() << "Thread running" << i;            sleep(1); *// 模拟耗时操作*        			}   

    	}

    };

   int main(int argc, char *argv[])

    {    

   ​		QCoreApplication a(argc, argv);     

   ​		MyThread thread;    

   ​		thread.start();    

   ​		 return a.exec(); 

   }

2. **使用 QObject 的子类**：创建一个继承自 `QObject` 的子类，将耗时操作封装在该类中的槽函数中，然后使用 `moveToThread()` 将该对象移动到新创建的线程中。

   示例代码：

   \#include <QCoreApplication> 

   #include <QThread> 

   #include <QDebug>

   class Worker : public QObject 

   {    

   ​	Q_OBJECT 

   ​	public slots:    void doWork() 

   ​	{        

   ​			for (int i = 0; i < 5; ++i)

   ​			 {            

   ​				qDebug() << "Worker running" << i;            

   ​					QThread::sleep(1); *// 模拟耗时操作*       

   ​			 }       

   ​			 emit workFinished();    

   ​	} 

   ​	signals:    void workFinished();

    };

   int main(int argc, char *argv[]) 

   {    

   ​	QCoreApplication a(argc, argv);     

   ​	QThread workerThread;    

   ​	Worker worker;    

   ​	worker.moveToThread(&workerThread);        

   ​	QObject::connect(&workerThread, &QThread::started, &worker, &Worker::doWork);    

   ​	QObject::connect(&worker, &Worker::workFinished, &workerThread, &QThread::quit);     

   ​	workerThread.start();    

   ​	return a.exec(); 

   }

3. **信号与槽机制**：通过信号与槽机制实现线程间的通信，比如在线程完成任务时发出信号通知主线程。

​	**5.Linux系统有使用过吗？做过开发吗？国产化的系统有使用过吗？**

​			有。有用过虚拟机开发g++.

​			没有，有了解几个国产化系统：中标麒麟，银河麒麟操作系统，深度Linux。

​	**6.数据库有使用过吗？Oracle有用过吗？**

​		有的。MySQL。

​		没有用过。Oracle是关系型数据库管理系统，依靠强大的高性能、可靠性，被广泛应用于企业级应用和大型系统中。

​	**7.界面部分的QSS用的多吗？**

​		多，略过。

​	**8.你对信号和槽的理解是怎么样的？**

​		Qt中的信号和槽是用于**对象间通信的机制**。（异步通信方式）

​		8.1**信号（Signal）**：

​		信号是Qt中特有的一种机制，用于在对象发生特定事件时通知其他对象。

​		信号由特殊的宏定义，如 `Q_SIGNALS`，声明在类的 `signals:` 部分，并没有实际的函数体。

​		当对象的状态发生变化或特定事件发生时，可以通过调用 `emit` 关键字来发射（触发）信号。

​		8.2**槽（Slot）**：

​		槽是用于接收信号的特殊成员函数，可以响应特定的信号。

​		槽函数可以是普通的成员函数，不需要使用特殊的关键字声明。

​		将槽函数与信号关联（连接）起来，当信号被发射时，槽函数会被自动调用。

**8.3信号与槽的连接**：

​		使用 `QObject::connect` 函数可以将信号与槽函数进行连接，建立对象之间的通信。

​		连接时需要指定信号源、信号、槽函数所属对象以及槽函数。

​		一个信号可以连接多个槽，一个槽也可以响应多个信号。

8.4特点和优势：

​		信号和槽机制是Qt框架的重要特性，实现了松耦合的对象间通信，使代码更加灵活和可维护。

​		支持跨线程的信号和槽连接，方便在多线程应用程序中实现对象间的异步通信。

​		可以自定义信号和槽，实现自定义事件的处理和传递。

​	**9.软件程序运行起来比较耗时，怎么处理？有什么手段？**

​				两种方式，第一种用多线程，后台加载数据，界面行运行起来，第二种就是通过事件机制，先将事件发送出去，放到事件队列中，这样主界面不会卡顿，等到主事件循环获取控制权时，会触发事件处理。

1. **代码优化**：
   - 对程序进行性能分析，找出性能瓶颈所在的代码段。
   - 优化算法和数据结构，减少不必要的计算或内存开销。
   - 避免过多的循环嵌套和递归调用，尽量减少函数调用开销。
2. **并行处理**：
   - 使用多线程或并发处理，将耗时的任务分解成多个子任务并行执行，以提高整体处理速度。
   - 合理利用CPU的多核资源，将不同任务分配给不同的核心并行处理。
3. **延迟加载**：
   - 将程序启动时不必要的资源加载延迟到实际需要时再加载，以减少启动时间。
   - 可以采用惰性加载的方式，只在需要时才初始化和加载相关资源。
4. **界面优化**
   - 采取渐进式加载的方式，先显示核心内容，然后再加载其他部分内容，以提高用户看到界面的速度。
   - 避免在界面加载时执行耗时操作，如网络请求、数据库查询等，可以采用异步方式完成这些操作。

5.**缓存机制**：

- 使用缓存技术来存储计算结果或频繁访问的数据，避免重复计算或I/O操作。

6.**性能测试和监控**：

- 进行系统负载测试和性能测试，找出系统瓶颈和性能瓶颈，并及时优化。
- 实时监控系统运行情况，发现性能问题并及时处理。

7.**性能调试器（Performance Profiler）**：

- Visual Studio内置了性能调试器，可以对应用程序进行性能分析和剖析。
- 开发者可以使用性能调试器来检测程序中的性能瓶颈，找出耗时的函数或代码段，并优化性能。

​	**10.异步处理，你了解吗？异步处理的方法你知道有哪些吗？信号和槽也可以实现异步（了解一下怎么实现），信号和槽的第五个参数。**

​	异步处理是一种**编程模式**，允许程序在执行某个操作时不必等待其完成，而是继续执行其他任务，提高程序的响应性和效率。

​	我了解三种方式：

​	1.回调函数。

- 在异步任务完成后，通过回调函数来处理任务的结果。
- 异步任务执行完毕后，会调用预先定义好的回调函数，并将结果作为参数传递给回调函数。

​	2.Promise/Deferred

- Promise/Deferred 是一种用于异步编程的设计模式，用于处理异步任务的结果。
- 通过Promise对象表示一个尚未完成的操作，并使用then()方法指定操作完成后的处理逻辑。

​	3.异步函数（**Async/Await**）

使用async关键字定义异步函数，可以在函数内部使用await关键字等待异步操作的完成。

信号和槽异步：信号和槽机制可以用于实现异步处理。基本思想是，某个对象发出信号，其他对象通过连接到这个信号的槽函数来接收信号并进行相应的处理。由于信号和槽之间是**异步**的，所以可以实现**非阻塞**的事件处理。



​	**11.事件有接触过吗？用事件做过开发吗？用事件如何做异步处理？**

​		接触过。有。键盘、鼠标、绘图、定时器、关闭、焦点、拖放（**Drag and Drop Events**）、自定义事件。

​	Qt的事件处理是基于**事件循环**的，而事件循环本身就是一种**异步处理机制**。

​		1.**自定义事件**：在需要进行异步处理的地方，可以定义一个自定义事件，例如`CustomEvent`。

​		2.**重写事件处理函数**：在相关的Qt对象（如QWidget或QCoreApplication）中，重写`event`方法，处理自定义事件。当自定义事件发生时，会触发相应的事件处理函数。

​		3.**使用定时器**：可以创建一个定时器，在定时器的时间间隔内执行异步操作。当定时器超时时，会触发定时器事件，可以在定时器事件处理函数中执行异步操作

​	**12.你做网络主要是做了哪些工作？（问项目）**

​		自己发挥。

​	**13.数据库，你对表的优化有过了解吗？**

​		**题目：有一些数据，分别在两个表里存的，但是我要你用一个SQL语句查出来，怎么查？怎么写？**

​		了解一些：优化方式：

​		1.**合适的数据类型** （使用合适的数据类型来存储数据，避免使用过大或不必要的数据类型，以节省存储空间和提高查询速度。）

​		2.**索引优化**（为经常用于检索的列创建索引，可以加快查询速度。避免创建过多索引，因为每个索引都会占用额外的空间并影响写入性能。） 

​		3.**查询优化**（编写高效的SQL查询语句，避免使用SELECT * 和不必要的JOIN操作。使用EXPLAIN语句来分析查询执行计划，优化慢查询。）

​		 4.**适当的缓存设置**（合理设置查询缓存、查询缓存大小等参数，可以减少数据库访问次数，提高性能。）



​	题目解答：可以使用**INNER JOIN**语句连接两个表。示例：

​	**SELECT** table1.height, table2.weight 

​	**FROM** table1

​	**INNER JOIN** table2 **ON** table1.name = table2.name 

​	**WHERE** table1.name = '小明';



​	**14.你会给其他人介绍一些技术，主要是哪方向？主要有哪些呢?**

​		自由发挥。

​	**15.你对薪资的需求？**

​	**16.介绍公司环境，办公环境。**

​	**17.多久能入职？**

​	**18.反问？**

​	1.问了对我这次面试的建议 2.问了薪酬结构，公积金缴纳基数和比例，年终奖，单双休。

建议：掌握比较单一，用国产系统做开发，需要在Linux系统下做开发。多线程，异步处理需要了解。



三、北京踏歌智行科技有限公司	  0306	15-23k

​	**1.自我介绍**

​	**2.Qt用了多久？用的哪个版本？主要在什么环境下开发的？Linux下面的开发多吗？**

​		5.9跟5.15

​	**3.你们用的cMake还是qMake?cMake了解吗？**

​		我说的qMake

​		CMake 和 QMake 都是用于构建 C++ 项目的工具。

​		在使用上，如果你主要是开发 Qt 项目，那么可以选择使用 QMake 来管理项目的构建过程；如果你需要一个更通用的构建系统，并且希望支持多种平台和构建工具，那么可以选择使用 CMake。另外，由于 CMake 的灵活性和广泛应用，一些大型项目也更倾向于选择 CMake 来管理构建过程。

1. **CMake**：
   - CMake 是一个跨平台的开源构建系统，用于管理项目的构建过程。
   - CMake 使用 CMakeLists.txt 文件来描述项目的构建规则和依赖关系，通过生成适合不同构建工具（如 Makefile、Visual Studio 项目等）的配置文件来实现构建过程。
   - CMake 支持多种编译器和构建工具，可以生成不同平台下的构建文件，使得项目能够在各种操作系统上进行构建。

   2.**QMake**：

- QMake 是 Qt 框架自带的构建工具，专门用于管理 Qt 项目的构建过程。
- QMake 使用 .pro 文件来描述项目的构建规则和配置信息，可以指定项目文件、资源文件、依赖库等。
- QMake 对于 Qt 项目的构建和部署提供了方便的支持，可以自动生成 Makefile 或 Visual Studio 项目文件等。

​	**4.Qt用过哪些控件？**

​		说了一些常用的。pass。

​	**5.你说下MVC的架构你们平时怎么用的？实现的什么样的功能？QListView和QListWidget？有什么区别？哪个更好用？**

MVC（Model-View-Controller）是一种常用的**软件架构模式**，用于将应用程序的逻辑、数据和用户界面分离，以提高代码的**可维护性**和**灵活性**。在实际开发中，我们通常会按照以下方式使用 MVC 架构：

1. **Model（模型）**：
   - 模型层负责处理应用程序的数据逻辑，包括数据的获取、处理、存储等。
   - 模型通常包含数据结构、数据库交互、业务逻辑等部分。
   - 在实际应用中，模型通常由各种数据对象、实体类或服务组成，用于表示应用程序所处理的数据。
2. **View（视图）**：
   - 视图层负责显示用户界面，将数据呈现给用户并接收用户输入。
   - 视图通常包括用户界面元素、布局、样式等部分。
   - 在实际应用中，视图可以是 GUI 元素、Web 页面、移动应用界面等，用于展示数据和与用户交互。
3. **Controller（控制器）**：
   - 控制器层充当模型和视图之间的中介，负责处理用户输入、更新模型数据和更新视图显示。
   - 控制器通常包含应用程序的业务逻辑、用户操作的处理逻辑等部分。
   - 在实际应用中，控制器根据用户的操作调用相应的模型方法来处理数据，并更新视图以反映数据的变化。

在实践中，我们通常将不同功能模块划分到对应的 MVC 组件中，以便更好地管理和维护代码。例如，在一个 Web 应用程序中，我们可能会将**数据处理**的代码放在模型中，将**页面渲染**的代码放在视图中，将**用户请求处理**的代码放在控制器中。

具体实现的功能取决于应用程序的需求，但一般来说，MVC 架构常用于开发各种类型的应用程序，包括 Web 应用、桌面应用、移动应用等。通过使用 MVC 架构，开发人员能够更好地组织代码、分离关注点，并实现应用程序的灵活性和可扩展性。

1. **QListView**：
   - `QListView` 是一个基本的列表视图类，用于显示由模型提供的数据。它通常需要一个数据模型（如 `QStandardItemModel`）来提供数据，并通过委托来定义每个列表项的外观。
   - `QListView` 提供了更灵活的定制选项，可以自定义列表项的外观和布局，以满足特定需求。
   - 由于 `QListView` 是更底层的视图类，因此在使用时需要更多的代码来实现特定的功能。
2. **QListWidget**：
   - `QListWidget` 是一个高级的列表部件类，它封装了 `QListView`、`QListWidgetItems` 和一些默认行为，使得显示简单的列表数据变得更加容易。
   - `QListWidget` 可以直接添加、删除和管理列表项，而无需指定单独的数据模型。
   - `QListWidget` 提供了方便的方法来操作列表项，如添加图标、设置文字等，使得在简单场景下更易于使用。

**哪个更好用？**

- 如果您需要更高度的自定义和灵活性，以及对列表项的外观和布局有特殊要求，那么 `QListView` 是一个更好的选择。
- 如果您只需要显示简单的列表数据，并且不需要太多自定义或特殊布局，那么 `QListWidget` 可能更适合您，因为它提供了更简单的界面和操作方式。

​	**6.说一下Qt里面的connect是怎么实现的？信号和槽底层是怎么实现的？**

在 Qt 中，信号和槽（Signals and Slots）是一种强大的机制，用于处理对象之间的通信。`connect` 函数用于建立信号和槽之间的连接关系。

##### 1. 信号和槽的基本原理：

- 信号是对象发出的事件，槽是对这些事件作出响应的函数。
- `QObject` 类是 Qt 中支持信号和槽机制的基类。
- `QObject` 类中包含了 `QObject::connect` 函数，用于建立信号和槽之间的连接。

##### 2. 信号和槽的底层实现：

- Qt 使用元对象系统（Meta-Object System）来实现信号和槽机制。
- 在编译阶段，Qt 的元对象编译器 (MOC) 会解析源文件中的信号和槽声明，并生成相应的元对象代码。
- 元对象包含了信号和槽的信息，以及对象的属性、方法等信息。
- 在运行时，当信号被触发时，会根据元对象系统查找与信号相关联的槽，并调用槽函数进行处理。

##### 3. `connect` 函数的工作原理：

- `QObject::connect` 函数用于建立信号和槽之间的连接，其参数包括信号发送者、信号、槽接收者以及槽函数。
- `connect` 函数会在元对象系统中查找信号和槽的对应关系，并建立连接。
- 当信号被发射时，会通过元对象系统找到与之相关联的槽，并调用槽函数。

​	**7.connect第五个参数有几种连接方式？什么时候用不同的连接模式？还有用过线程间信号和槽连接？有什么区别？如果让你写线程之间，线程A和线程B，信号在线程A，线程B是槽，你用哪个连接方式？有什么区别吗？为什么不直接连接？**

​	5种。

1. **Auto Connection（自动连接）**：
   - 这是默认的连接类型，由 Qt 根据情况自动选择连接方式。
   - 如果信号发送者和槽接收者在同一线程，那么会使用直接连接；如果在不同线程，则会使用队列连接（Queued Connection）。
2. **Direct Connection（直接连接）**：
   - 信号发出后，槽函数会立即在信号发出的线程中执行。
   - 适用于信号发出者和槽接收者在同一线程，并且需要实时响应的场景。
3. **Queued Connection（队列连接）**：
   - 信号发出后，对应的槽函数会被放入接收者对象所属线程的事件队列中，等待事件循环处理。
   - 适用于信号发出者和槽接收者在不同线程的情况，通过事件队列实现线程间的安全通信。
4. **Blocking Queued Connection（阻塞队列连接）**：
   - 类似于队列连接，但是发出信号的线程会等待槽函数执行完毕才继续执行。
   - 适用于信号发出者和槽接收者在不同线程，且信号发出者需要等待槽函数执行完毕的场景。

  5、**Qt::UniqueConnection**：这个flag可以通过按位或（|）与以上四个结合在一起使用。当这个flag设置时，当某个信号和槽已经连接时，再进行重复的连接就会失败。也就是为了**避免重复连接。**



对于线程间的信号和槽连接，在多线程编程中，建议使用**队列连接**（Queued Connection）或**阻塞队列连接**（Blocking Queued Connection）。这是因为直接连接（Direct Connection）会导致槽函数在信号发送者所在线程执行，可能引发**线程安全问题**。而队列连接可以确保槽函数在接收者所属线程中执行，避免了**竞态条件和数据竞争**等问题。

对于给定的情况，如果信号在线程A，槽在线程B，且需要确保线程安全，我会选择使用**队列连接**（Queued Connection）或者**阻塞队列连接**（Blocking Queued Connection）。这样可以确保槽函数在线程B中执行，**避免线程间的竞态条件**，同时**保证线程A不会被阻塞**。如果直接连接，那么槽函数将在线程A中执行，可能引发线程安全问题。因此，为了线程安全考虑，应该选择队列连接或阻塞队列连接。

​	**8.为什么new QWidget 为什么不需要delete？父对象跟子对象，父对象delete之后，子对象会delete吗？比如我们有一个大的Widget，然后里面有很多我们自定义的小的widget，如果大的widget delete后，那些子的widget会自动delete吗？Qt有个机制，QOBject，对象树 你有了解吗？你写widget的时候不需要设置他的父对象吗？为啥要设置为parent？在Qt中，在注意控件要设置父指针，不delete的话，好多会漏掉，那你平常写一个控件，都要delete吗？我都设置父对象。**

通常情况下不需要手动调用 `delete` 来释放内存。这是因为 Qt 中引入了**父子关系**以及**对象树**的概念，Qt 会负责管理对象的内存释放。

在 Qt 中，如果一个对象 A 是另一个对象 B 的父对象（通过设置 B 的父指针为 A），那么当父对象 A 被删除时，Qt 会自动删除其所有的子对象，即子对象会被自动释放。这种自动释放的机制可以帮助我们避免内存泄漏和手动管理对象释放的复杂性。

对于你提到的情况，如果你有一个大的 `QWidget`，里面包含了很多小的自定义 `QWidget`，如果大的 `QWidget` 被删除，那些子 `QWidget` 会被自动删除，因为它们与大 `QWidget` 存在父子关系。

在 Qt 中，确保正确设置父对象是很重要的。通过设置父对象，你可以让 Qt 自动管理对象的内存释放，避免内存泄漏。平时在编写控件时，确实不需要手动调用 `delete` 来释放内存，只需设置好父对象即可。这样做能够简化代码，提高效率，并且避免遗漏释放对象的情况。

在 Qt 中，**对象树**是指通过设置**父子关系**来管理对象之间的层次结构的机制。每个 QObject 类的实例都可以有一个父对象，并且一个父对象可以拥有多个子对象，这样就形成了一个树形结构。对象树在 Qt 中有以下几个主要作用：

1. **内存管理**：当一个对象被设置为另一个对象的父对象时，父对象负责管理其子对象的生命周期。当父对象被销毁时，它会自动销毁所有的子对象，从而避免内存泄漏。
2. **事件传递**：Qt 中的事件传递机制是基于对象树的结构进行的。当一个对象接收到事件时，事件会首先传递给该对象，然后逐级向上遍历父对象，直到根对象，以确保所有相关对象都有机会处理该事件。
3. **资源管理**：通过对象树，可以方便地组织和管理各个对象，使代码结构更清晰，便于整体操作和处理对象。

在实际的 Qt 应用程序开发中，特别是在 GUI 编程中，对象树是非常重要的概念。通过**正确设置父子关系**，可以让 Qt 自动处理对象的创建和销毁，简化内存管理，并确保事件传递的正确性。

​	**9.你常用手动编写代码还是用Qt designer方式？像根据界面自动缩放的这种，你怎么去布局？怎么适配不同分辨率的屏幕？控件是可以缩放，且布局是不变的，这边怎么处理？**

1. 使用**布局管理器**（Layout Manager）：Qt 提供了丰富的布局管理器，如 QVBoxLayout、QHBoxLayout、QGridLayout 等，这些布局管理器可以根据容器的大小自动调整内部控件的布局。通过合理使用布局管理器，可以实现界面的自动缩放和适配不同分辨率的屏幕，而不需要手动调整控件的位置和大小。
2. 使用**尺寸策略**（Size Policy）：每个控件都可以设置自己的尺寸策略，包括水平和垂直方向上的尺寸策略。通过设置合适的尺寸策略，可以让控件在布局时自动适应父容器的大小，并根据需要进行缩放。
3. **自定义窗口缩放事件**处理：在 Qt 中，可以重写 QWidget 的 **resizeEvent** 事件来处理窗口大小变化时的布局调整。在 resizeEvent 中，可以根据新的窗口大小重新计算控件的位置和大小，从而实现自定义的缩放逻辑。
4. 使用界面文件（如.ui 文件）：如果你使用 Qt Designer 创建界面，可以在.ui 文件中使用**布局管理器**和**尺寸策略**来实现自动缩放和适配不同分辨率的屏幕。Qt Designer 提供了可视化的界面设计工具，方便你进行界面布局的设计和调整。

​	**10.Qt事件你了解吗？用过哪些事件？你用鼠标事件一般自定义控件过吗？是自定义的吗？中间会出现什么问题吗？**

​	**11.Qt多线程了解吗？怎么保证多线程安全啊？加锁是哪几个接口？用过吗？Qt的线程类除了QThread，还有其他的吗？还有简洁的比较小的那种。**

​		怎么保证：

​		使用互斥锁（Mutex）：通过 QMutex、QMutexLocker 等类来进行线程间的互斥操作，避免多个线程同时访问共享资源。

​		使用信号与槽机制：Qt 的信号与槽机制可以跨线程地进行通信，从而避免直接的线程间数据共享。

​	接口：

- QMutex：用于实现互斥锁的类。
- QMutexLocker：用于自动管理互斥锁的类，可以在作用域内自动上锁和解锁。
- QReadWriteLock：读写锁，用于支持多个线程对数据进行读操作，但只允许一个线程进行写操作。

除了 QThread 外，Qt 还提供了其他的线程相关类，比如：

- QtConcurrent：提供了简洁的并发编程接口，可以方便地进行任务的并行执行。
- QThreadPool：线程池类，可以管理和调度多个线程执行任务。
- QRunnable：可运行对象接口，可以实现自定义的可运行对象，并交给线程池执行。

**有没有简洁的比较小的线程类？** 如果你需要更加**轻量级**的线程类，可以考虑使用 QtConcurrent 或者自定义 QRunnable，并交给 QThreadPool 来执行。这些类可以帮助你简洁地实现多线程任务的并行执行，而不需要直接操作线程。

​	**12.线程之间Move对象用过吗？**

在 Qt 中，可以使用 QObject 的 moveToThread() 方法来实现将一个对象移动到另一个线程中执行。

通过调用 QObject 的 moveToThread() 方法，可以将该对象移动到指定的线程中，从而确保该对象在新线程中被正确处理。这样做可以避免跨线程访问造成的数据竞争和不确定行为。

*// 创建一个 QObject 对象* 

QObject *object = new QObject; 

*// 创建一个新线程* 

QThread *thread = new QThread; 

*// 将对象移动到新线程* 

object->moveToThread(thread); 

*// 连接对象的信号和槽* 

connect(object, &QObject::destroyed, thread, &QThread::quit); 

*// 启动新线程* 

thread->start();

​	**13.那你这两年主要是写的哪方面的？那后台C++那些逻辑之间的逻辑有写过吗？**

​	**14.网络编程这块有写过吗？是什么协议？**

​	**15.TCP、UDP这种的写过吗?了解吗？用这种TCP去写过客户端跟服务端吗？**

​	**16.平时写东西，开源的没有涉及吗？**

​	**17.QML有用过吗，了解吗，尝试过吗？**

QML 是一种用于创建用户界面的声明性语言，通常与 Qt 框架一起使用。

QML 允许开发人员通过描述 UI 元素之间的关系和属性来定义界面，而无需编写大量的代码。

​	**18.C++了解多少？我答了STL。**

​	**19.都用过STL的哪些东西？Qt有对应吗？**

​	**20.题目：现在有两个QList，怎么让这两个list从头往后寻找，同时到达他们的节点？两个list有交点，从两个list的头开始往后找，怎么同时到达他们的交点？另一个面试官：你知道他这题的意思吗？**

要同时遍历两个 QList 并找到它们的交点，可以使用**两个指针**分别指向两个 QList 的头部，并同时向后移动直到其中一个指针到达末尾。一旦到达末尾，将该指针重置到另一个 QList 的头部，然后继续向后移动，直到两个指针相遇。这种方法可以保证在遍历过程中同时到达两个列表的交点。

\#include <QList> 

#include <QDebug> 

*// 定义一个简单的节点结构* 

struct Node {   

 int value;    

Node* next; };



*// 找到两个 QList 的交点*

 Node* findIntersection(QList<Node*> list1, QList<Node*> list2) 

{

​	 if (list1.isEmpty() || list2.isEmpty()) 

​		{

​		 return nullptr;

  	 }

​    Node* ptr1 = list1.first();   

 Node* ptr2 = list2.first();



 while (ptr1 != ptr2) 

​	{        

​	ptr1 = ptr1->next ? ptr1->next : list2.first();        

​	ptr2 = ptr2->next ? ptr2->next : list1.first();    

​	}

  return ptr1;

}

int main() 

{    

*// 创建两个 QList*    

QList<Node*> list1;    *

*QList<Node*> list2;    

 *// 假设这里创建了两个有交点的链表*    

 *// 找到交点*    

Node* intersection = findIntersection(list1, list2);     

if (intersection) 

{       

​	 qDebug() << "Found intersection at value: " << intersection->value;   

 } 

else 

{       

 qDebug() << "No intersection found.";    

}    

 return 0; 

}

解释：

在这段代码中，我们定义了一个简单的 Node 结构表示链表的节点，然后实现了 findIntersection 函数来找到两个 QList 的交点。在主函数中，我们可以创建两个包含交点的链表，并调用 findIntersection 函数来查找它们的交点，并输出交点的值。

​	**21.反问？**

​		**建议：基础知识要加强，两年应该不只是只接触界面，应该更扩充一些。突然提问：1.你都用过哪些开源的第三方库？Boost里面哪些模块你用到了，shared_ptr是Boost里面的吗？Boost里面有一些智能指针是C++标准库里没有的。还有吗？你感兴趣的。我说了我搭过chatgpt。还有其他的吗，证明自己的学习能力。C++、Qt这块，有开源的项目吗？2.你怎么Qt中，你如何画一个图表，类似与坐标系中动态的曲线。需要什么控件吗？我说重写paintEvent。用过吗，做的什么样的功能？你平常学Qt，看了什么样的书，视频，网站，这些途径从哪来？ QML用的少？学习的一个方向和态度。**

boost::shared_ptr，shared_ptr最初可能是在 Boost 中引入的。

了解一下：

以下是 Boost 库中一些常见的模块和组件：

1. Smart Pointers（智能指针）
2. Threads（线程）
3. Containers（容器）
4. Algorithms（算法）
5. File System（文件系统）
6. Date Time（日期时间）
7. Regular Expressions（正则表达式）
8. Math（数学）
9. Networking（网络）
10. Serialization（序列化）。

四、国科恒通（上海）  0308   11-16K

**一面：1.自我介绍**

**2.你平时工作的时候会用到数据库吗？你自己有学过数据库的基本增删改查的？如何查找表里年龄是20岁的人？如何找到这张表年龄最大的值是谁怎么找？用MySQL写排序的语句怎么写？**

**3.笔试题（2）问问题。**

**4.笔试题（3）问问题。如果数组全是负数，如何求一个浮点数数组的最大值最小值跟平均值？（排序？）**

**5.随便说一个排序的算法？（我说了冒泡跟快排）**

**6.你平时工作跟学习有没有用过C++11的特性？有用过智能指针吗？说一下C++里面几种常用的智能指针？能说一下shared_ptr大概的一个原理吗？我们为什么要用智能指针，不用裸指针？他在什么情况下会去回收数据呢？只要智能指针析构就会释放里面数据吗？**

**7.你能说一下Qt里面的信号和槽吗？**

**8.能说一下connect这个函数吗？**

**9.在我们连接信号和槽的时候，有没有什么办法判断是否连接成功了？**

**10.如何实现一个界面的小功能，说一下全部的实现流程？**

**自己发挥。**

**11.反问？**

**12.建议：C++基础知识要加强，链表去写一下。**

**二面：1.自我介绍**

**2.问了一下基本情况。谈薪。**

**3.介绍业务啥的：电网的图形管理系统。**

**4.反问？谈薪啥的。**

五、上海汇正财经  0311   15-25K

**1.自我介绍。**

**2.你说你做过分享，你能抽一个你觉得还可以的讲一下吗？**

**3.在这一份工作中你觉得你收获了一些什么？**

**4.你现在什么原因换工作？说了调岗，问：调岗去做了什么？**

**5.你的个人优势是什么？说了抗压，问：抗压能举个例子吗？**

**6.你觉得你在前面的工作中，有什么突出的表现吗？在团队里有什么突出点吗？**

**7.跨平台开发过吗？做过跨平台开发吗？你们的应用是在不同的平台上运行的吗？**

**8.你们Qt版本是多少？你们从低版本到高版本迭代（5.9-5.15），迭代的过程中你做了些什么？库的升级啊谁在做？**

**9.信号和槽的原理是什么？**

**10.反问？**

**11.建议：想要看到突出点，让同事或领导认同的点，可以在这方面多说一些东西，（做股票投资展示客户端）。**