## 面试公司及时复盘

一、中科合讯（北京，军工外包） 02.26    15-25k

**1.面试官稍微介绍一下公司（军工外包项目）**

**2.自我介绍**

**3.Qt的信号和槽和Qt的事件有什么区别？**

​	Qt中的信号和槽是用于**对象间通信的机制**，而事件则是用于**处理用户输入和系统事件的机制**。

​	信号和槽：1.信号和槽是Qt中一种灵活的机制，用于实现对象之间的通信。一个对象可以发射信号，而其他对象可以连接这个信号并在接收到信号时执行相应的槽函数。

2.信号和槽是完全异步的，发送信号的对象不需要等待槽函数执行完成，从而实现了对象之间的解耦。

3.信号和槽是Qt的一个重要特性，可以跨线程使用，非常适合实现用户界面响应和事件处理等功能。

​	事件：1.事件是Qt中另一个重要的机制，用于处理用户输入（如鼠标点击、键盘输入）以及系统事件（如定时器事件、窗口事件等）。

2.Qt中的事件是基于事件循环机制的，当事件发生时，Qt会将事件发送给指定的对象，并由该对象的事件处理函数进行处理。

3.事件处理是同步的，即事件发生后，事件处理函数会立即执行，直到事件处理完成才会返回。

**4.Qt信号和槽的连接有几种方式？哪几种？**

​	**4种。**

​	1.使用SIGNAL和SLOT宏连接信号与槽。

```cpp
QPushButton* button = new QPushButton("Click Me");
connect(button, SIGNAL(clicked()), this, SLOT(onButtonClicked()));
```

​	2.使用lambda表达式连接信号和槽。

```cpp
QSlider* slider = new QSlider();
connect(slider, SIGNAL(valueChanged(int)), [=](int value) {
    // 处理滑块值改变的逻辑
});
```

​	3.使用Qt5的新语法连接信号和槽，使用指针函数的地址作为参数，可以在编译时进行类型检查。

```cpp
QAction* action = new QAction("Open", this);
connect(action, &QAction::triggered, this, &MainWindow::onOpenClicked);
```

​	4.使用自定义信号和槽函数，在适当的时机通过 emit 关键字触发信号。

```cpp
// 自定义信号的声明
signals:
    void myCustomSignal(int value);

// 自定义槽函数的声明
public slots:
    void myCustomSlot(int value);

// 在适当的位置触发信号
emit myCustomSignal(42);

// 连接自定义信号与槽函数
connect(senderObject, SIGNAL(myCustomSignal(int)), receiverObject, SLOT(myCustomSlot(int)));
```

**5.QGraphicsView 用过没有？（场景，视图，和图元）。**

​	它是 Qt 中用于显示图形项（Graphics Items）的视图类。QGraphicsView 是一个用于显示 QGraphicsScene 中图形项的可视化部件，可以在其中显示和交互多个图形项，如文本、图像、矩形、椭圆等。

**6.Qt的事件过滤你知道嘛？了解吗？事件过滤的作用？**

​	事件过滤的作用：是一种机制，允许你在特定对象上拦截和处理事件，而不修改原始对象的代码。事件过滤器可以用于捕获、过滤和处理各种事件，包括键盘事件、鼠标事件、定时器事件等。

1.扩展事件处理能力：通过事件过滤器，你可以在一个对象上添加额外的事件处理逻辑，而无需修改原始对象的代码。这样可以扩展对象的事件处理能力，实现更复杂的交互逻辑或功能。

2.事件过滤和拦截：事件过滤器可以拦截某个对象接收到的事件，进行自定义处理，然后决定是否将事件传递给原始对象继续处理。这样可以在事件传递过程中进行干预，实现事件的过滤和拦截，例如屏蔽某些特定的事件或修改事件的属性。

3.动态事件处理：事件过滤器可以动态地选择性地处理事件，根据事件的具体属性或上下文来决定是否处理。这样可以根据需要对事件进行条件处理，灵活地控制事件的处理逻辑。

4.对象间通信：通过事件过滤器，你可以在不同对象之间实现事件的传递和通信。例如，你可以将一个事件过滤器安装在父级对象上，拦截子对象的事件并进行处理，实现对象间的消息传递和交互。

**7.你平时在用Qt的时候用了哪些东西？哪些技术？**

1. **界面设计与布局**：使用Qt Designer设计界面，利用Qt的布局管理器（如QVBoxLayout、QHBoxLayout、QGridLayout等）来实现界面布局，确保界面在不同平台和分辨率下都能正确显示。
2. **信号与槽机制**：利用Qt的信号与槽机制实现对象之间的通信和交互，让不同部件之间能够响应事件、更新数据，并实现模块之间的解耦。
3. **网络编程**：使用Qt的网络模块（如QTcpSocket、QUdpSocket、QNetworkAccessManager等）进行网络编程，实现与服务器的数据通讯、HTTP请求等功能。
4. 数据库操作：通过Qt的SQL模块连接各种数据库（如SQLite、MySQL等），执行SQL查询、插入、更新、删除等操作，实现数据的持久化存储和管理。
5. 多线程编程：利用Qt的多线程模块（如QThread、QtConcurrent等）实现多线程编程，提高程序的并发性能，避免阻塞主线程。
6. **文件操作**：使用Qt的文件操作类（如QFile、QDir等）进行文件读写、目录操作，实现文件的读取、保存、导出等功能。
7. **定时器与事件处理**：利用Qt的定时器类（如QTimer）实现定时任务，处理定时事件；同时结合事件过滤器等机制，对用户输入和系统事件进行处理。
8. **跨平台开发**：利用Qt的跨平台性，编写一套代码可以在不同操作系统（如Windows、macOS、Linux等）上运行，减少开发和维护成本。

**8.Qt读写xml,用过几种方式？**

​	三种。

1.QXmlStreamReader：一种快速的基于流的方式访问良格式 XML 文档，特别适合于实现一次解析器（所谓“一次解析器”，可以理解成我们只需读取文档一次，然后像一个遍历器从头到尾一次性处理 XML 文档，期间不会有反复的情况，也就是不会读完第一个标签，然后读第二个，读完第二个又返回去读第一个，这是不允许的）；

2.DOM（Document Object Model）：将整个 XML 文档读入内存，构建成一个树结构，允许程序在树结构上向前向后移动导航，这是与另外两种方式最大的区别，也就是允许实现多次解析器（对应于前面所说的一次解析器）。DOM 方式带来的问题是需要一次性将整个 XML 文档读入内存，因此会占用很大内存.

3.SAX（Simple API for XML）：提供大量虚函数，以事件的形式处理 XML 文档。这种解析办法主要是由于历史原因提出的，为了解决 DOM 的内存占用提出的（在现代计算机上，这个一般已经不是问题了）。

**9.QDomDocument,几个类的关系是怎么样的？**

​	`QDomDocument` 类是用于处理XML文档的核心类，它提供了创建、操作和解析XML文档的功能。

1.**QDomNode**：`QDomNode` 是 XML 文档中节点的基类，它可以代表文档、元素、属性、文本等不同类型的节点。`QDomNode` 提供了访问节点的方法和属性，以及节点之间的关系。

2.**QDomElement**：`QDomElement` 继承自 `QDomNode`，表示 XML 文档中的元素节点。`QDomElement` 包含了元素的标签名、属性、子元素等信息，可以通过它来操作和处理 XML 元素。

3.**QDomAttr**：`QDomAttr` 继承自 `QDomNode`，表示 XML 元素的属性节点。`QDomAttr` 用于表示元素的属性名称和属性值，可以通过它来获取和设置元素的属性。

4.**QDomText**：`QDomText` 继承自 `QDomNode`，表示 XML 文档中的文本节点。`QDomText` 用于表示元素内的文本内容，可以通过它来读取和修改元素的文本数据。

5.**QDomNodeList**：`QDomNodeList` 是一个节点列表类，用于存储一组节点对象。通过 `QDomNodeList` 可以方便地对节点进行遍历和访问，获取节点的数量、迭代节点等操作。

**10.Qt的绘图你用过？**

1. **QWidget**：QWidget 是Qt中所有用户界面对象的基类，也是绘图的基础。你可以通过重写 QWidget 的 `paintEvent` 函数，在其中使用 QPainter 进行绘图操作。
2. **QPainter**：QPainter 是Qt提供的2D绘图引擎，用于在QWidget或QPixmap等设备上进行绘图操作。你可以使用 QPainter 绘制各种几何图形（如直线、矩形、椭圆等）、文本、图像等。
3. **QPaintDevice**：QPaintDevice 是绘图设备的基类，它可以是QWidget、QPixmap、QImage等。通过继承 QPaintDevice，你可以创建自定义的绘图设备，实现离屏渲染等功能。
4. **QPen** 和 **QBrush**：QPen 用于定义绘制线条的样式（如颜色、宽度、风格），而 QBrush 用于定义填充区域的样式（如颜色、填充模式）。在绘制图形时，通过设置 QPen 和 QBrush 可以实现不同的效果。

**11.Qt的模式和视图有什么好处（MVC）？**

​	模式（Model）和视图（View）是一种常用的设计模式，它将数据和用户界面分离开来，使得数据和界面之间的交互变得更加灵活和可扩展。(C: control 控制)。

1.**分离数据和UI**：模式和视图将数据和用户界面分离开来，使得数据的存储、处理、显示等操作与UI的布局、控件等操作相互独立。这种分离有助于代码的可维护性和重用性，使得程序的架构更加清晰和易于扩展。

2.**支持多种数据源**：模式和视图允许使用不同的数据源（如数据库、XML文档、JSON文件等）来填充数据模型，从而可以更方便地处理和显示数据。数据源可以通过模型接口（如QAbstractItemModel）来实现，而视图则通过代理对象（如QStyledItemDelegate）来控制数据的显示和编辑。

3.**提供灵活的数据呈现方式**：Qt的模式和视图提供了丰富的数据呈现方式，包括列表、树形、表格、图形等多种视图类型。用户可以根据实际需求选择适合的视图类型，以获得最佳的数据呈现效果。

4.**支持数据排序和过滤**：Qt的模式和视图支持数据的排序和过滤，可以按照任意列进行升序或降序排序，也可以根据用户输入的筛选条件过滤数据。这种功能使得用户可以更方便地浏览和管理大量的数据。

5.**支持数据编辑和更新**：Qt的模式和视图支持数据的编辑和更新，用户可以通过界面控件来修改数据并将其保存到数据源中。这种功能使得程序更加灵活和交互性强，同时也提高了用户的工作效率。

**12.你知道基类的析构函数为什么声明为虚的吗？（virtual）**

​	这是因为当我们使用指向派生类对象的基类指针或引用时，如果基类的析构函数不是虚函数，那么在delete一个指向派生类对象的基类指针时，只会调用基类的析构函数，而不会调用派生类的析构函数，导致派生类的资源无法被正确地释放，从而可能导致内存泄漏或其他错误。

​	而通过将基类的析构函数声明为虚函数，C++编译器就能够在运行时确定所指向的实际对象类型，并自动调用该对象类型对应的析构函数，从而保证了对象的正确释放。因此，在使用C++多态时，通常都需要将基类的析构函数声明为虚函数，以确保正确的析构行为。

**13.C++里面，对多态的理解？**

多态：它使得程序能够更加灵活、可扩展和易于维护。

在C++中，多态体现在两个方面，运行时多态和编译时多态。

1.运行时多态（动态多态）

运行时多态是指在程序运行时根据对象的实际类型来确定调用哪个函数的机制。在C++中，通过使用**虚函数**和**基类指针或引用**，可以实现运行时多态。

具体来说，当我们使用基类指针或引用来调用虚函数时，如果该指针或引用指向了派生类对象，那么程序就会自动调用派生类中对应的虚函数，而不是基类中的函数。这种机制可以让程序更加灵活和可扩展，因为我们可以在派生类中覆盖（override）基类的虚函数，从而实现不同的行为。****

2.编译时多态（静态多态）

编译时多态是指在程序编译时就可以确定调用哪个函数的机制。在C++中，编译时多态主要体现在**函数重载**和**模板**的使用上。

函数重载允许我们定义多个**同名函数**，但它们的**参数列表不同**，从而可以根据函数的参数类型和数量来确定调用哪个函数。这种机制可以让程序更加灵活和易于维护，因为我们可以用相同的函数名来表示不同的行为。

模板是一种通用编程技术，它允许我们定义一组可以适用于不同数据类型的函数或类。通过使用模板参数，我们可以在编译时生成多个不同的函数或类，从而实现编译时多态。

**14.Linux操作系统你用过吗？**

​	常用的快捷键

**15.你大概什么能到岗？**

**16.你期望薪资？**

**17.反问？**

​	1.问了对我的建议 2.问了有没有人带。

对我的建议：多看，多练，多写，多思考，多总结，不要怕犯错。数据结构和算法，设计模式都没问。问题：知其然不知其所以然。封装String类。封装，继承，多态，抽象？ 时间对程序员是最重要的，每天多学1-2个小时。

不要依靠师傅带，要靠自己，要独立。自己要锻炼，自己要成长。讲业务，业务可以带，程序上不要想着别人带。



二、北京国遥新天地（军工外包）	0301			20-21k

​	**1.自我介绍**

​	**2.你一直在用QT吗？还用过其他的什么吗？**

​		2.1 qt界面一共两大块 我们用的qWidgets，QML没用。

​		2.2 还用过Boost库，智能指针shared_ptr,用于管理动态内存，避免内存泄漏和悬空指针问题。	

​		2.3 STL库。vector（动态数组），list（双向链表），deque(双端队列)，map（键唯一，值对应键），set（插入的元素不重复）

​	**3.你这边用QT相关的技术有哪些？**

1. **界面设计与布局**：使用Qt Designer设计界面，利用Qt的布局管理器（如QVBoxLayout、QHBoxLayout、QGridLayout等）来实现界面布局，确保界面在不同平台和分辨率下都能正确显示。

2. **信号与槽机制**：利用Qt的信号与槽机制实现对象之间的通信和交互，让不同部件之间能够响应事件、更新数据，并实现模块之间的解耦。

3. **网络编程**：使用Qt的网络模块（如QTcpSocket、QUdpSocket、**QNetworkAccessManager**等）进行网络编程，实现与服务器的数据通讯、HTTP请求等功能。

4. **数据库操作**：通过Qt的SQL模块连接各种数据库（如SQLite、MySQL等），执行SQL查询、插入、更新、删除等操作，实现数据的持久化存储和管理。

   4.1查询：**SELECT** column1, column2, ... **FROM** table_name **WHERE** condition;举例：SELECT * FROM customers WHERE city = 'Beijing';

   4.2 插入：I**NSERT INTO** table_name (column1, column2, ...) **VALUES** (value1, value2, ...);举例：INSERT INTO customers (name, city, age) VALUES ('John', 'Shanghai', 30);

   4.3更新：**UPDATE** table_name **SET** column1 = value1, column2 = value2, ... **WHERE** condition;举例：UPDATE customers SET city = 'Beijing' WHERE id = 1;

   4.4删除：**DELETE FROM** table_name **WHERE condition**;举例：DELETE FROM customers WHERE id = 1;

5. **多线程编程**：利用Qt的多线程模块（如QThread、QtConcurrent等）实现多线程编程，提高程序的并发性能，避免阻塞主线程。

6. **文件操作**：使用Qt的文件操作类（如QFile、QDir等）进行文件读写、目录操作，实现文件的读取、保存、导出等功能。

7. **定时器与事件处理**：利用Qt的定时器类（如QTimer）实现定时任务，处理定时事件；同时结合事件过滤器等机制，对用户输入和系统事件进行处理。

8. **跨平台开发**：利用Qt的跨平台性，编写一套代码可以在不同操作系统（如Windows、macOS、Linux等）上运行，减少开发和维护成本。

​	**4.多线程有使用过吗？**

​		有的。在 Qt 中进行多线程编程可以使用 `QThread` 类来创建和管理线程，同时也可以利用**信号与槽**机制来实现线程间的通信。

##### 	多线程使用方法

1. **继承 QThread 类**：创建一个新的类并继承自 `QThread`，重写 `run()` 方法，在 `run()` 方法内编写线程要执行的代码。

   示例代码：

   \#include <QThread> 

   #include <QDebug> 

   class MyThread : public QThread 

   { 

   ​	public:    void run() override

   ​	 {        

   ​			for (int i = 0; i < 5; ++i) 

   ​			{            qDebug() << "Thread running" << i;            sleep(1); *// 模拟耗时操作*        			}   

    	}

    };

   int main(int argc, char *argv[])

    {    

   ​		QCoreApplication a(argc, argv);     

   ​		MyThread thread;    

   ​		thread.start();    

   ​		 return a.exec(); 

   }

2. **使用 QObject 的子类**：创建一个继承自 `QObject` 的子类，将耗时操作封装在该类中的槽函数中，然后使用 `moveToThread()` 将该对象移动到新创建的线程中。

   示例代码：

   \#include <QCoreApplication> 

   #include <QThread> 

   #include <QDebug>

   class Worker : public QObject 

   {    

   ​	Q_OBJECT 

   ​	public slots:    void doWork() 

   ​	{        

   ​			for (int i = 0; i < 5; ++i)

   ​			 {            

   ​				qDebug() << "Worker running" << i;            

   ​					QThread::sleep(1); *// 模拟耗时操作*       

   ​			 }       

   ​			 emit workFinished();    

   ​	} 

   ​	signals:    void workFinished();

    };

   int main(int argc, char *argv[]) 

   {    

   ​	QCoreApplication a(argc, argv);     

   ​	QThread workerThread;    

   ​	Worker worker;    

   ​	worker.moveToThread(&workerThread);        

   ​	QObject::connect(&workerThread, &QThread::started, &worker, &Worker::doWork);    

   ​	QObject::connect(&worker, &Worker::workFinished, &workerThread, &QThread::quit);     

   ​	workerThread.start();    

   ​	return a.exec(); 

   }

3. **信号与槽机制**：通过信号与槽机制实现线程间的通信，比如在线程完成任务时发出信号通知主线程。

​	**5.Linux系统有使用过吗？做过开发吗？国产化的系统有使用过吗？**

​			有。有用过虚拟机开发g++.

​			没有，有了解几个国产化系统：中标麒麟，银河麒麟操作系统，深度Linux。

​	**6.数据库有使用过吗？Oracle有用过吗？**

​		有的。MySQL。

​		没有用过。Oracle是关系型数据库管理系统，依靠强大的高性能、可靠性，被广泛应用于企业级应用和大型系统中。

​	**7.界面部分的QSS用的多吗？**

​		多，略过。

​	**8.你对信号和槽的理解是怎么样的？**

​		Qt中的信号和槽是用于**对象间通信的机制**。（异步通信方式）

​		8.1**信号（Signal）**：

​		信号是Qt中特有的一种机制，用于在对象发生特定事件时通知其他对象。

​		信号由特殊的宏定义，如 `Q_SIGNALS`，声明在类的 `signals:` 部分，并没有实际的函数体。

​		当对象的状态发生变化或特定事件发生时，可以通过调用 `emit` 关键字来发射（触发）信号。

​		8.2**槽（Slot）**：

​		槽是用于接收信号的特殊成员函数，可以响应特定的信号。

​		槽函数可以是普通的成员函数，不需要使用特殊的关键字声明。

​		将槽函数与信号关联（连接）起来，当信号被发射时，槽函数会被自动调用。

**8.3信号与槽的连接**：

​		使用 `QObject::connect` 函数可以将信号与槽函数进行连接，建立对象之间的通信。

​		连接时需要指定信号源、信号、槽函数所属对象以及槽函数。

​		一个信号可以连接多个槽，一个槽也可以响应多个信号。

8.4特点和优势：

​		信号和槽机制是Qt框架的重要特性，实现了松耦合的对象间通信，使代码更加灵活和可维护。

​		支持跨线程的信号和槽连接，方便在多线程应用程序中实现对象间的异步通信。

​		可以自定义信号和槽，实现自定义事件的处理和传递。

​	**9.软件程序运行起来比较耗时，怎么处理？有什么手段？**

​				两种方式，第一种用多线程，后台加载数据，界面行运行起来，第二种就是通过事件机制，先将事件发送出去，放到事件队列中，这样主界面不会卡顿，等到主事件循环获取控制权时，会触发事件处理。

1. **代码优化**：
   - 对程序进行性能分析，找出性能瓶颈所在的代码段。
   - 优化算法和数据结构，减少不必要的计算或内存开销。
   - 避免过多的循环嵌套和递归调用，尽量减少函数调用开销。
2. **并行处理**：
   - 使用多线程或并发处理，将耗时的任务分解成多个子任务并行执行，以提高整体处理速度。
   - 合理利用CPU的多核资源，将不同任务分配给不同的核心并行处理。
3. **延迟加载**：
   - 将程序启动时不必要的资源加载延迟到实际需要时再加载，以减少启动时间。
   - 可以采用惰性加载的方式，只在需要时才初始化和加载相关资源。
4. **界面优化**
   - 采取渐进式加载的方式，先显示核心内容，然后再加载其他部分内容，以提高用户看到界面的速度。
   - 避免在界面加载时执行耗时操作，如网络请求、数据库查询等，可以采用异步方式完成这些操作。

5.**缓存机制**：

- 使用缓存技术来存储计算结果或频繁访问的数据，避免重复计算或I/O操作。

6.**性能测试和监控**：

- 进行系统负载测试和性能测试，找出系统瓶颈和性能瓶颈，并及时优化。
- 实时监控系统运行情况，发现性能问题并及时处理。

7.**性能调试器（Performance Profiler）**：

- Visual Studio内置了性能调试器，可以对应用程序进行性能分析和剖析。
- 开发者可以使用性能调试器来检测程序中的性能瓶颈，找出耗时的函数或代码段，并优化性能。

​	**10.异步处理，你了解吗？异步处理的方法你知道有哪些吗？信号和槽也可以实现异步（了解一下怎么实现），信号和槽的第五个参数。**

​	异步处理是一种**编程模式**，允许程序在执行某个操作时不必等待其完成，而是继续执行其他任务，提高程序的响应性和效率。

​	我了解三种方式：

​	1.回调函数。

- 在异步任务完成后，通过回调函数来处理任务的结果。
- 异步任务执行完毕后，会调用预先定义好的回调函数，并将结果作为参数传递给回调函数。

​	2.Promise/Deferred

- Promise/Deferred 是一种用于异步编程的设计模式，用于处理异步任务的结果。
- 通过Promise对象表示一个尚未完成的操作，并使用then()方法指定操作完成后的处理逻辑。

​	3.异步函数（**Async/Await**）

使用async关键字定义异步函数，可以在函数内部使用await关键字等待异步操作的完成。

信号和槽异步：信号和槽机制可以用于实现异步处理。基本思想是，某个对象发出信号，其他对象通过连接到这个信号的槽函数来接收信号并进行相应的处理。由于信号和槽之间是**异步**的，所以可以实现**非阻塞**的事件处理。



​	**11.事件有接触过吗？用事件做过开发吗？用事件如何做异步处理？**

​		接触过。有。键盘、鼠标、绘图、定时器、关闭、焦点、拖放（**Drag and Drop Events**）、自定义事件。

​	Qt的事件处理是基于**事件循环**的，而事件循环本身就是一种**异步处理机制**。

​		1.**自定义事件**：在需要进行异步处理的地方，可以定义一个自定义事件，例如`CustomEvent`。

​		2.**重写事件处理函数**：在相关的Qt对象（如QWidget或QCoreApplication）中，重写`event`方法，处理自定义事件。当自定义事件发生时，会触发相应的事件处理函数。

​		3.**使用定时器**：可以创建一个定时器，在定时器的时间间隔内执行异步操作。当定时器超时时，会触发定时器事件，可以在定时器事件处理函数中执行异步操作

​	**12.你做网络主要是做了哪些工作？（问项目）**

​		自己发挥。

​	**13.数据库，你对表的优化有过了解吗？**

​		**题目：有一些数据，分别在两个表里存的，但是我要你用一个SQL语句查出来，怎么查？怎么写？**

​		了解一些：优化方式：

​		1.**合适的数据类型** （使用合适的数据类型来存储数据，避免使用过大或不必要的数据类型，以节省存储空间和提高查询速度。）

​		2.**索引优化**（为经常用于检索的列创建索引，可以加快查询速度。避免创建过多索引，因为每个索引都会占用额外的空间并影响写入性能。） 

​		3.**查询优化**（编写高效的SQL查询语句，避免使用SELECT * 和不必要的JOIN操作。使用EXPLAIN语句来分析查询执行计划，优化慢查询。）

​		 4.**适当的缓存设置**（合理设置查询缓存、查询缓存大小等参数，可以减少数据库访问次数，提高性能。）



​	题目解答：可以使用**INNER JOIN**语句连接两个表。示例：

​	**SELECT** table1.height, table2.weight 

​	**FROM** table1

​	**INNER JOIN** table2 **ON** table1.name = table2.name 

​	**WHERE** table1.name = '小明';



​	**14.你会给其他人介绍一些技术，主要是哪方向？主要有哪些呢?**

​		自由发挥。

​	**15.你对薪资的需求？**

​	**16.介绍公司环境，办公环境。**

​	**17.多久能入职？**

​	**18.反问？**

​	1.问了对我这次面试的建议 2.问了薪酬结构，公积金缴纳基数和比例，年终奖，单双休。

建议：掌握比较单一，用国产系统做开发，需要在Linux系统下做开发。多线程，异步处理需要了解。



三、北京踏歌智行科技有限公司	  0306	15-23k

​	**1.自我介绍**

​	**2.Qt用了多久？用的哪个版本？主要在什么环境下开发的？Linux下面的开发多吗？**

​		5.9跟5.15

​	**3.你们用的cMake还是qMake?cMake了解吗？**

​		我说的qMake

​		CMake 和 QMake 都是用于构建 C++ 项目的工具。

​		在使用上，如果你主要是开发 Qt 项目，那么可以选择使用 QMake 来管理项目的构建过程；如果你需要一个更通用的构建系统，并且希望支持多种平台和构建工具，那么可以选择使用 CMake。另外，由于 CMake 的灵活性和广泛应用，一些大型项目也更倾向于选择 CMake 来管理构建过程。

1. **CMake**：
   - CMake 是一个跨平台的开源构建系统，用于管理项目的构建过程。
   - CMake 使用 CMakeLists.txt 文件来描述项目的构建规则和依赖关系，通过生成适合不同构建工具（如 Makefile、Visual Studio 项目等）的配置文件来实现构建过程。
   - CMake 支持多种编译器和构建工具，可以生成不同平台下的构建文件，使得项目能够在各种操作系统上进行构建。

   2.**QMake**：

- QMake 是 Qt 框架自带的构建工具，专门用于管理 Qt 项目的构建过程。
- QMake 使用 .pro 文件来描述项目的构建规则和配置信息，可以指定项目文件、资源文件、依赖库等。
- QMake 对于 Qt 项目的构建和部署提供了方便的支持，可以自动生成 Makefile 或 Visual Studio 项目文件等。

​	**4.Qt用过哪些控件？**

​		说了一些常用的。pass。

​	**5.你说下MVC的架构你们平时怎么用的？实现的什么样的功能？QListView和QListWidget？有什么区别？哪个更好用？**

MVC（Model-View-Controller）是一种常用的**软件架构模式**，用于将应用程序的逻辑、数据和用户界面分离，以提高代码的**可维护性**和**灵活性**。在实际开发中，我们通常会按照以下方式使用 MVC 架构：

1. **Model（模型）**：
   - 模型层负责处理应用程序的数据逻辑，包括数据的获取、处理、存储等。
   - 模型通常包含数据结构、数据库交互、业务逻辑等部分。
   - 在实际应用中，模型通常由各种数据对象、实体类或服务组成，用于表示应用程序所处理的数据。
2. **View（视图）**：
   - 视图层负责显示用户界面，将数据呈现给用户并接收用户输入。
   - 视图通常包括用户界面元素、布局、样式等部分。
   - 在实际应用中，视图可以是 GUI 元素、Web 页面、移动应用界面等，用于展示数据和与用户交互。
3. **Controller（控制器）**：
   - 控制器层充当模型和视图之间的中介，负责处理用户输入、更新模型数据和更新视图显示。
   - 控制器通常包含应用程序的业务逻辑、用户操作的处理逻辑等部分。
   - 在实际应用中，控制器根据用户的操作调用相应的模型方法来处理数据，并更新视图以反映数据的变化。

在实践中，我们通常将不同功能模块划分到对应的 MVC 组件中，以便更好地管理和维护代码。例如，在一个 Web 应用程序中，我们可能会将**数据处理**的代码放在模型中，将**页面渲染**的代码放在视图中，将**用户请求处理**的代码放在控制器中。

具体实现的功能取决于应用程序的需求，但一般来说，MVC 架构常用于开发各种类型的应用程序，包括 Web 应用、桌面应用、移动应用等。通过使用 MVC 架构，开发人员能够更好地组织代码、分离关注点，并实现应用程序的灵活性和可扩展性。

1. **QListView**：
   - `QListView` 是一个基本的列表视图类，用于显示由模型提供的数据。它通常需要一个数据模型（如 `QStandardItemModel`）来提供数据，并通过委托来定义每个列表项的外观。
   - `QListView` 提供了更灵活的定制选项，可以自定义列表项的外观和布局，以满足特定需求。
   - 由于 `QListView` 是更底层的视图类，因此在使用时需要更多的代码来实现特定的功能。
2. **QListWidget**：
   - `QListWidget` 是一个高级的列表部件类，它封装了 `QListView`、`QListWidgetItems` 和一些默认行为，使得显示简单的列表数据变得更加容易。
   - `QListWidget` 可以直接添加、删除和管理列表项，而无需指定单独的数据模型。
   - `QListWidget` 提供了方便的方法来操作列表项，如添加图标、设置文字等，使得在简单场景下更易于使用。

**哪个更好用？**

- 如果您需要更高度的自定义和灵活性，以及对列表项的外观和布局有特殊要求，那么 `QListView` 是一个更好的选择。
- 如果您只需要显示简单的列表数据，并且不需要太多自定义或特殊布局，那么 `QListWidget` 可能更适合您，因为它提供了更简单的界面和操作方式。

​	**6.说一下Qt里面的connect是怎么实现的？信号和槽底层是怎么实现的？**

在 Qt 中，信号和槽（Signals and Slots）是一种强大的机制，用于处理对象之间的通信。`connect` 函数用于建立信号和槽之间的连接关系。

##### 1. 信号和槽的基本原理：

- 信号是对象发出的事件，槽是对这些事件作出响应的函数。
- `QObject` 类是 Qt 中支持信号和槽机制的基类。
- `QObject` 类中包含了 `QObject::connect` 函数，用于建立信号和槽之间的连接。

##### 2. 信号和槽的底层实现：

- Qt 使用元对象系统（Meta-Object System）来实现信号和槽机制。
- 在编译阶段，Qt 的元对象编译器 (MOC) 会解析源文件中的信号和槽声明，并生成相应的元对象代码。
- 元对象包含了信号和槽的信息，以及对象的属性、方法等信息。
- 在运行时，当信号被触发时，会根据元对象系统查找与信号相关联的槽，并调用槽函数进行处理。

##### 3. `connect` 函数的工作原理：

- `QObject::connect` 函数用于建立信号和槽之间的连接，其参数包括信号发送者、信号、槽接收者以及槽函数。
- `connect` 函数会在元对象系统中查找信号和槽的对应关系，并建立连接。
- 当信号被发射时，会通过元对象系统找到与之相关联的槽，并调用槽函数。

​	**7.connect第五个参数有几种连接方式？什么时候用不同的连接模式？还有用过线程间信号和槽连接？有什么区别？如果让你写线程之间，线程A和线程B，信号在线程A，线程B是槽，你用哪个连接方式？有什么区别吗？为什么不直接连接？**

​	5种。

1. **Auto Connection（自动连接）**：
   - 这是默认的连接类型，由 Qt 根据情况自动选择连接方式。
   - 如果信号发送者和槽接收者在同一线程，那么会使用直接连接；如果在不同线程，则会使用队列连接（Queued Connection）。
2. **Direct Connection（直接连接）**：
   - 信号发出后，槽函数会立即在信号发出的线程中执行。
   - 适用于信号发出者和槽接收者在同一线程，并且需要实时响应的场景。
3. **Queued Connection（队列连接）**：
   - 信号发出后，对应的槽函数会被放入接收者对象所属线程的事件队列中，等待事件循环处理。
   - 适用于信号发出者和槽接收者在不同线程的情况，通过事件队列实现线程间的安全通信。
4. **Blocking Queued Connection（阻塞队列连接）**：
   - 类似于队列连接，但是发出信号的线程会等待槽函数执行完毕才继续执行。
   - 适用于信号发出者和槽接收者在不同线程，且信号发出者需要等待槽函数执行完毕的场景。

  5、**Qt::UniqueConnection**：这个flag可以通过按位或（|）与以上四个结合在一起使用。当这个flag设置时，当某个信号和槽已经连接时，再进行重复的连接就会失败。也就是为了**避免重复连接。**



对于线程间的信号和槽连接，在多线程编程中，建议使用**队列连接**（Queued Connection）或**阻塞队列连接**（Blocking Queued Connection）。这是因为直接连接（Direct Connection）会导致槽函数在信号发送者所在线程执行，可能引发**线程安全问题**。而队列连接可以确保槽函数在接收者所属线程中执行，避免了**竞态条件和数据竞争**等问题。

对于给定的情况，如果信号在线程A，槽在线程B，且需要确保线程安全，我会选择使用**队列连接**（Queued Connection）或者**阻塞队列连接**（Blocking Queued Connection）。这样可以确保槽函数在线程B中执行，**避免线程间的竞态条件**，同时**保证线程A不会被阻塞**。如果直接连接，那么槽函数将在线程A中执行，可能引发线程安全问题。因此，为了线程安全考虑，应该选择队列连接或阻塞队列连接。

​	**8.为什么new QWidget 为什么不需要delete？父对象跟子对象，父对象delete之后，子对象会delete吗？比如我们有一个大的Widget，然后里面有很多我们自定义的小的widget，如果大的widget delete后，那些子的widget会自动delete吗？Qt有个机制，QOBject，对象树 你有了解吗？你写widget的时候不需要设置他的父对象吗？为啥要设置为parent？在Qt中，在注意控件要设置父指针，不delete的话，好多会漏掉，那你平常写一个控件，都要delete吗？我都设置父对象。**

通常情况下不需要手动调用 `delete` 来释放内存。这是因为 Qt 中引入了**父子关系**以及**对象树**的概念，Qt 会负责管理对象的内存释放。

在 Qt 中，如果一个对象 A 是另一个对象 B 的父对象（通过设置 B 的父指针为 A），那么当父对象 A 被删除时，Qt 会自动删除其所有的子对象，即子对象会被自动释放。这种自动释放的机制可以帮助我们避免内存泄漏和手动管理对象释放的复杂性。

对于你提到的情况，如果你有一个大的 `QWidget`，里面包含了很多小的自定义 `QWidget`，如果大的 `QWidget` 被删除，那些子 `QWidget` 会被自动删除，因为它们与大 `QWidget` 存在父子关系。

在 Qt 中，确保正确设置父对象是很重要的。通过设置父对象，你可以让 Qt 自动管理对象的内存释放，避免内存泄漏。平时在编写控件时，确实不需要手动调用 `delete` 来释放内存，只需设置好父对象即可。这样做能够简化代码，提高效率，并且避免遗漏释放对象的情况。

在 Qt 中，**对象树**是指通过设置**父子关系**来管理对象之间的层次结构的机制。每个 QObject 类的实例都可以有一个父对象，并且一个父对象可以拥有多个子对象，这样就形成了一个树形结构。对象树在 Qt 中有以下几个主要作用：

1. **内存管理**：当一个对象被设置为另一个对象的父对象时，父对象负责管理其子对象的生命周期。当父对象被销毁时，它会自动销毁所有的子对象，从而避免内存泄漏。
2. **事件传递**：Qt 中的事件传递机制是基于对象树的结构进行的。当一个对象接收到事件时，事件会首先传递给该对象，然后逐级向上遍历父对象，直到根对象，以确保所有相关对象都有机会处理该事件。
3. **资源管理**：通过对象树，可以方便地组织和管理各个对象，使代码结构更清晰，便于整体操作和处理对象。

在实际的 Qt 应用程序开发中，特别是在 GUI 编程中，对象树是非常重要的概念。通过**正确设置父子关系**，可以让 Qt 自动处理对象的创建和销毁，简化内存管理，并确保事件传递的正确性。

​	**9.你常用手动编写代码还是用Qt designer方式？像根据界面自动缩放的这种，你怎么去布局？怎么适配不同分辨率的屏幕？控件是可以缩放，且布局是不变的，这边怎么处理？**

1. 使用**布局管理器**（Layout Manager）：Qt 提供了丰富的布局管理器，如 QVBoxLayout、QHBoxLayout、QGridLayout 等，这些布局管理器可以根据容器的大小自动调整内部控件的布局。通过合理使用布局管理器，可以实现界面的自动缩放和适配不同分辨率的屏幕，而不需要手动调整控件的位置和大小。
2. 使用**尺寸策略**（Size Policy）：每个控件都可以设置自己的尺寸策略，包括水平和垂直方向上的尺寸策略。通过设置合适的尺寸策略，可以让控件在布局时自动适应父容器的大小，并根据需要进行缩放。
3. **自定义窗口缩放事件**处理：在 Qt 中，可以重写 QWidget 的 **resizeEvent** 事件来处理窗口大小变化时的布局调整。在 resizeEvent 中，可以根据新的窗口大小重新计算控件的位置和大小，从而实现自定义的缩放逻辑。
4. 使用界面文件（如.ui 文件）：如果你使用 Qt Designer 创建界面，可以在.ui 文件中使用**布局管理器**和**尺寸策略**来实现自动缩放和适配不同分辨率的屏幕。Qt Designer 提供了可视化的界面设计工具，方便你进行界面布局的设计和调整。

​	**10.Qt事件你了解吗？用过哪些事件？你用鼠标事件一般自定义控件过吗？是自定义的吗？中间会出现什么问题吗？**

​	**11.Qt多线程了解吗？怎么保证多线程安全啊？加锁是哪几个接口？用过吗？Qt的线程类除了QThread，还有其他的吗？还有简洁的比较小的那种。**

​		怎么保证：

​		使用互斥锁（Mutex）：通过 QMutex、QMutexLocker 等类来进行线程间的互斥操作，避免多个线程同时访问共享资源。

​		使用信号与槽机制：Qt 的信号与槽机制可以跨线程地进行通信，从而避免直接的线程间数据共享。

​	接口：

- QMutex：用于实现互斥锁的类。
- QMutexLocker：用于自动管理互斥锁的类，可以在作用域内自动上锁和解锁。
- QReadWriteLock：读写锁，用于支持多个线程对数据进行读操作，但只允许一个线程进行写操作。

除了 QThread 外，Qt 还提供了其他的线程相关类，比如：

- QtConcurrent：提供了简洁的并发编程接口，可以方便地进行任务的并行执行。
- QThreadPool：线程池类，可以管理和调度多个线程执行任务。
- QRunnable：可运行对象接口，可以实现自定义的可运行对象，并交给线程池执行。

**有没有简洁的比较小的线程类？** 如果你需要更加**轻量级**的线程类，可以考虑使用 QtConcurrent 或者自定义 QRunnable，并交给 QThreadPool 来执行。这些类可以帮助你简洁地实现多线程任务的并行执行，而不需要直接操作线程。

​	**12.线程之间Move对象用过吗？**

在 Qt 中，可以使用 QObject 的 moveToThread() 方法来实现将一个对象移动到另一个线程中执行。

通过调用 QObject 的 moveToThread() 方法，可以将该对象移动到指定的线程中，从而确保该对象在新线程中被正确处理。这样做可以避免跨线程访问造成的数据竞争和不确定行为。

*// 创建一个 QObject 对象* 

QObject *object = new QObject; 

*// 创建一个新线程* 

QThread *thread = new QThread; 

*// 将对象移动到新线程* 

object->moveToThread(thread); 

*// 连接对象的信号和槽* 

connect(object, &QObject::destroyed, thread, &QThread::quit); 

*// 启动新线程* 

thread->start();

​	**13.那你这两年主要是写的哪方面的？那后台C++那些逻辑之间的逻辑有写过吗？**

​	**14.网络编程这块有写过吗？是什么协议？**

​	**15.TCP、UDP这种的写过吗?了解吗？用这种TCP去写过客户端跟服务端吗？**

​	**16.平时写东西，开源的没有涉及吗？**

​	**17.QML有用过吗，了解吗，尝试过吗？**

QML 是一种用于创建用户界面的声明性语言，通常与 Qt 框架一起使用。

QML 允许开发人员通过描述 UI 元素之间的关系和属性来定义界面，而无需编写大量的代码。

​	**18.C++了解多少？我答了STL。**

​	**19.都用过STL的哪些东西？Qt有对应吗？**

​	**20.题目：现在有两个QList，怎么让这两个list从头往后寻找，同时到达他们的节点？两个list有交点，从两个list的头开始往后找，怎么同时到达他们的交点？另一个面试官：你知道他这题的意思吗？**

要同时遍历两个 QList 并找到它们的交点，可以使用**两个指针**分别指向两个 QList 的头部，并同时向后移动直到其中一个指针到达末尾。一旦到达末尾，将该指针重置到另一个 QList 的头部，然后继续向后移动，直到两个指针相遇。这种方法可以保证在遍历过程中同时到达两个列表的交点。

\#include <QList> 

#include <QDebug> 

*// 定义一个简单的节点结构* 

struct Node {   

 int value;    

Node* next; };



*// 找到两个 QList 的交点*

 Node* findIntersection(QList<Node*> list1, QList<Node*> list2) 

{

​	 if (list1.isEmpty() || list2.isEmpty()) 

​		{

​		 return nullptr;

  	 }

​    Node* ptr1 = list1.first();   

 Node* ptr2 = list2.first();



 while (ptr1 != ptr2) 

​	{        

​	ptr1 = ptr1->next ? ptr1->next : list2.first();        

​	ptr2 = ptr2->next ? ptr2->next : list1.first();    

​	}

  return ptr1;

}

int main() 

{    

*// 创建两个 QList*    

QList<Node*> list1;    *

*QList<Node*> list2;    

 *// 假设这里创建了两个有交点的链表*    

 *// 找到交点*    

Node* intersection = findIntersection(list1, list2);     

if (intersection) 

{       

​	 qDebug() << "Found intersection at value: " << intersection->value;   

 } 

else 

{       

 qDebug() << "No intersection found.";    

}    

 return 0; 

}

解释：

在这段代码中，我们定义了一个简单的 Node 结构表示链表的节点，然后实现了 findIntersection 函数来找到两个 QList 的交点。在主函数中，我们可以创建两个包含交点的链表，并调用 findIntersection 函数来查找它们的交点，并输出交点的值。

​	**21.反问？**

​		**建议：基础知识要加强，两年应该不只是只接触界面，应该更扩充一些。突然提问：1.你都用过哪些开源的第三方库？Boost里面哪些模块你用到了，shared_ptr是Boost里面的吗？Boost里面有一些智能指针是C++标准库里没有的。还有吗？你感兴趣的。我说了我搭过chatgpt。还有其他的吗，证明自己的学习能力。C++、Qt这块，有开源的项目吗？2.你怎么Qt中，你如何画一个图表，类似与坐标系中动态的曲线。需要什么控件吗？我说重写paintEvent。用过吗，做的什么样的功能？你平常学Qt，看了什么样的书，视频，网站，这些途径从哪来？ QML用的少？学习的一个方向和态度。**

boost::shared_ptr，shared_ptr最初可能是在 Boost 中引入的。

了解一下：

以下是 Boost 库中一些常见的模块和组件：

1. Smart Pointers（智能指针）
2. Threads（线程）
3. Containers（容器）
4. Algorithms（算法）
5. File System（文件系统）
6. Date Time（日期时间）
7. Regular Expressions（正则表达式）
8. Math（数学）
9. Networking（网络）
10. Serialization（序列化）。

四、国科恒通（上海）  0308   11-16K

**一面：1.自我介绍**

**2.你平时工作的时候会用到数据库吗？你自己有学过数据库的基本增删改查的？如何查找表里年龄是20岁的人？如何找到这张表年龄最大的值是谁怎么找？用MySQL写排序的语句怎么写？**

**插入**数据：**INSERT INTO** table_name (column1, column2, column3, ...)
VALUES (value1, value2, value3, ...);

**删除**数据：**DELETE FROM** table_name
**WHERE** condition;

**更新**数据：**UPDATE** table_name
**SET** column1 = value1, column2 = value2, ...
**WHERE** condition;

**查询**数据：**SELECT** column1, column2, ...
**FROM** table_name
**WHERE** condition;

**SELECT** * **FROM** table_name **WHERE** age = 20;

**SELECT** * **FROM** table_name **ORDER BY** age **DESC** **LIMIT** 1;或者**SELECT MAX**(age) **FROM** table_name;（最小值同理）

**SELECT** * **FROM** table_name **ORDER BY** column_name **ASC**;  -- 按指定列**升序**排序
**SELECT** * **FROM** table_name **ORDER BY** column_name **DESC**; -- 按指定列**降序**排序

**3.笔试题（2）问问题。**

**4.笔试题（3）问问题。如果数组全是负数，如何求一个浮点数数组的最大值最小值跟平均值？（排序？）**

pass.

**5.随便说一个排序的算法？（我说了冒泡跟快排）**

pass.

**6.你平时工作跟学习有没有用过C++11的特性？有用过智能指针吗？说一下C++里面几种常用的智能指针？能说一下shared_ptr大概的一个原理吗？我们为什么要用智能指针，不用裸指针？他在什么情况下会去回收数据呢？只要智能指针析构就会释放里面数据吗？**

C++11 引入了一些重要的新特性，例如`auto` 关键字、范围循环、lambda 表达式、智能指针等。这些特性使得 C++ 更加现代化，提高了代码的可读性和可维护性。

范围循环适用于**支持迭代器的容器**，如数组、std::vector、std::list 等。

lambda表达式基本语法：[capture_list] (parameters) -> return_type {
    // 函数体
    return expression;
}

其中：

- `capture_list` 指定了 lambda 表达式所需**捕获的变量**。可以以**引用或者值**的方式进行捕获。
- `parameters` 定义了传递给 lambda 函数的**参数列表**。
- `return_type` 指定了**返回类型**，可以使用 `auto` 进行自动推导。
- 函数体内包含了要执行的具体操作，并且可以使用 `return` 返回值。

智能指针是 C++ 中用于管理**动态分配内存**的对象，它们可以**自动进行资源回收**，从而避免了内存泄漏和悬挂指针等问题。C++ 中几种常用的智能指针包括：

- `std::unique_ptr`：**独占**所有权的智能指针，不能被复制，确保在同一时间只有一个指针可以拥有资源。
- `std::shared_ptr`：**共享**所有权的智能指针，允许多个指针共享相同的资源，并且会进行引用计数来确保资源在最后一个引用被销毁时释放。
- `std::weak_ptr`：**弱引用**智能指针，用于打破 shared_ptr 的**循环引用**问题，不会增加引用计数，也不拥有资源。

`std::shared_ptr` 使用**引用计数**来跟踪共享的对象，并在最后一个引用离开作用域时**自动释放所管理的对象**。当引用计数变为 0 时，智能指针会**自动删除其所管理的对象**。

##### 我们使用智能指针而不使用裸指针的原因在于智能指针具有更好的内存管理能力，能够自动释放资源，避免**内存泄漏**和**悬挂指针**问题。

智能指针在引用计数归零时（即没有任何智能指针指向该对象时）会释放其管理的资源。这意味着只要最后一个智能指针离开作用域，其所管理的资源就会被释放。

不过需要注意的是，智能指针的析构只会释放其所管理的资源，如果存在循环引用，可能导致资源无法被释放。在处理循环引用时，可以考虑使用 `std::weak_ptr` 来打破循环引用链。

**7.你能说一下Qt里面的信号和槽吗？**

​	`QObject` 是 Qt 框架中一个非常重要的类，它提供了以下几个关键功能：

##### 对象树和父子关系管理

- `QObject` 支持对象树结构，允许将对象组织为层次化结构。这种结构使得当父对象被销毁时，其所有子对象也会自动被销毁。
- 父子对象之间的关系还决定了一些行为，比如事件传递和属性继承。

##### 信号和槽的支持

- `QObject` 提供了信号和槽机制，使得对象之间可以进行松散耦合的通信和事件处理。

##### 属性系统

- `QObject` 支持定义和使用属性（Property），可以通过属性系统实现对类成员变量的封装、监视和通知等功能。

##### 事件处理

- `QObject` 支持事件处理机制，使得可以方便地处理和分发事件。

##### 元对象系统

- `QObject` 是元对象系统的一部分，它能够利用元对象系统提供的反射能力，包括运行时类型信息和动态属性查询。

**`Q_OBJECT` 是一个宏，用于启用元对象系统（Meta-Object System）的特性**。

1. **信号和槽的支持**：包含 `Q_OBJECT` 宏的类可以定义和使用信号和槽，实现对象之间的松散耦合通信机制。

2. **元对象系统的特性**：启用元对象系统后，类就可以利用元对象系统提供的反射能力，比如动态地查询类的信息和属性、处理事件等。

3. **属性系统**：允许定义类的属性并且进行监视和通知。

4. **动态类型信息**：启用元对象系统后，类将具有运行时类型信息，使得可以进行动态属性查询和操作。

5. **Qt 元编程**：`Q_OBJECT` 的存在为 Qt 提供了一种基础，使得可以通过元编程技术来分析和操作包含 `Q_OBJECT` 宏的类。

   在 Qt 中，信号和槽（Signals and Slots）是一种强大的机制，用于处理对象之间的通信。`connect` 函数用于建立信号和槽之间的连接关系。

   ##### 原理：

   ##### 1. 信号和槽的基本原理：

   - 信号是对象发出的事件，槽是对这些事件作出响应的函数。
   - `QObject` 类是 Qt 中支持信号和槽机制的基类。
   - `QObject` 类中包含了 `QObject::connect` 函数，用于建立信号和槽之间的连接。

   ##### 2. 信号和槽的底层实现：

   - Qt 使用元对象系统（Meta-Object System）来实现信号和槽机制。
   - 在编译阶段，Qt 的元对象编译器 (MOC) 会解析源文件中的信号和槽声明，并生成相应的元对象代码。
   - 元对象包含了信号和槽的信息，以及对象的属性、方法等信息。
   - 在运行时，当信号被触发时，会根据元对象系统查找与信号相关联的槽，并调用槽函数进行处理。

   ##### 3. `connect` 函数的工作原理：

   - `QObject::connect` 函数用于建立信号和槽之间的连接，其参数包括信号发送者、信号、槽接收者以及槽函数。
   - `connect` 函数会在元对象系统中查找信号和槽的对应关系，并建立连接。
   - 当信号被发射时，会通过元对象系统找到与之相关联的槽，并调用槽函数。

**8.能说一下connect这个函数吗？**

从四个方面讲解一下：1功能2语法3参数4使用场景。

##### 功能

- **建立连接**：`connect` 函数用于将一个对象的信号与另一个对象的槽函数或全局函数相连接，从而实现对象之间的通信。
- **断开连接**：除了建立连接，`connect` 函数还可以用于断开已有的连接。

##### 语法

```
cpp复制代码QObject::connect(sender, SIGNAL(someSignal()), receiver, SLOT(someSlot()));
```

- `sender`：发出信号的对象。
- `SIGNAL(someSignal())`：定义了信号。
- `receiver`：接收并处理信号的对象。
- `SLOT(someSlot())`：定义了槽函数。

在 Qt5 中也提供了新的语法，使用函数指针来替代宏：

```
cpp复制代码connect(sender, &SenderClass::someSignal, receiver, &ReceiverClass::someSlot);
```

##### 参数

- **sender**：发出信号的对象，通常是继承自 `QObject` 的类的对象。
- **signal**：发送的信号，使用 `SIGNAL` 宏或者函数指针指定。
- **receiver**：接收并处理信号的对象，通常也是继承自 `QObject` 的类的对象。
- **slot**：处理信号的槽函数，使用 `SLOT` 宏或者函数指针指定。

##### 适用场景

- **用户界面编程**：用于处理按钮点击、菜单选择等用户交互事件。
- **多线程通信**：线程之间的数据传递和消息处理。

**9.在我们连接信号和槽的时候，有没有什么办法判断是否连接成功了？**

在 Qt 中，可以使用 `QObject::connect` 函数的返回值来判断连接是否成功。当 `connect` 成功建立连接时，它将返回一个 `QMetaObject::Connection` 对象，否则返回无效的连接对象。

QMetaObject::Connection connection = QObject::connect(sender, &SenderClass::someSignal, receiver, &ReceiverClass::someSlot);
if (connection) {
    // 连接成功建立
} else {
    // 连接建立失败
}

另一种方法是使用 `QMetaObject::Connection` 的 `disconnect` 方法，如果连接成功建立，则可以通过调用 `disconnect` 方法来断开连接。

QMetaObject::Connection connection = QObject::connect(sender, &SenderClass::someSignal, receiver, &ReceiverClass::someSlot);
if (connection) {
    // 连接成功建立
    QObject::disconnect(connection); // 断开连接
} else {
    // 连接建立失败
}

**10.如何实现一个界面的小功能，说一下全部的实现流程？**

pass.

**自己发挥。**

**11.反问？**

**12.建议：C++基础知识要加强，链表去写一下。**

**二面：1.自我介绍**

**2.问了一下基本情况。谈薪。**

**3.介绍业务啥的：电网的图形管理系统。**

**4.反问？谈薪啥的。**

五、上海汇正财经  0311   15-25K

**1.自我介绍。**

**2.你说你做过分享，你能抽一个你觉得还可以的讲一下吗？**

​	封装过的**工具类**：UI工具类： 字符转换，类型转换，判断文档路径，判断是否存在文件，判断目录是否存在，获取模块路径，读取XML，读取Json，获取当前时间字符串。

##### 主题：使用信号和槽实现事件驱动编程

- **详细内容**：
  1. **信号和槽的基本原理**：深入讨论信号和槽的工作原理，包括元对象系统（Meta-Object System）的机制，以及它们是如何实现松散耦合的。
  2. **在实际项目中的应用**：分享我在一个实际项目中使用信号和槽来处理用户交互、数据传递等方面的案例，详细说明如何设计和实现这些信号和槽的连接，以及它们对项目整体架构的影响。
  3. **多线程通信**：探讨如何利用信号和槽在多线程应用程序中进行通信，包括线程安全性考虑以及避免常见的多线程通信问题。
  4. **错误处理和调试技巧**：分享在建立信号和槽连接时如何进行错误处理，以及如何使用 Qt 工具和调试技巧来诊断和解决与信号和槽相关的问题。
- **演示**：
  - 展示一个简单的 Qt 应用程序的示例，演示如何创建对象之间的连接，发送和接收信号，以及展示信号触发后相关联的槽函数被调用的情况。同时，也可以演示在多线程环境下如何使用信号和槽进行通信。

**3.在这一份工作中你觉得你收获了一些什么？**

##### Bug定位：

- **调试技能提升**：通过处理各种不同类型的 bug，我学会了更加高效地使用调试器和日志工具，从而可以快速地定位问题所在，并编写相应的修复代码。
- **跨模块协作**：在解决 bug 的过程中，我积累了大量的跨模块协作的经验，包括与其他团队成员合作分析和定位系统级别的问题。

##### 类设计：

- **优秀的设计实践**：我在项目中负责设计和实现了多个模块和组件，这使我明白了良好的类设计是如何影响整个系统的可扩展性和可维护性。
- **设计原则应用**：我在设计类时尽量遵循单一职责原则、开闭原则等设计原则，以确保所设计的类具有良好的灵活性和可扩展性。

##### 设计模式：

- **应用设计模式**：在项目中，我积极运用了诸如工厂模式、观察者模式、策略模式等设计模式，以解决特定的设计问题，同时也使得系统更易于维护和扩展。
- **设计思想培养**：通过应用设计模式，我培养了对于如何将通用的设计思想和模式应用到实际业务场景中的能力，从而提高了项目代码的灵活性和可读性。

**4.你现在什么原因换工作？**

​	不涨薪。

**5.你的个人优势是什么？**

##### 	学习能力与适应性强。学习Qt方面知识 ，通过查文档，搜索资料，短时间做出来一个小功能之类的。适应性强：领导分配一个我并不熟悉的业务，比如构件开发，讲一下自己如何熟悉开发流程，并快速上手解决业务问题。

**6.你觉得你在前面的工作中，有什么突出的表现吗？在团队里有什么突出点吗？**

**项目经验与贡献：**

我在上一份工作中承担了多个基于Qt的项目，其中最显著的是ABC项目。我在该项目中对界面设计和功能实现做出了重要贡献。举例来说，在ABC项目中，我负责设计和实现了一个复杂的用户界面，其中涉及到大量的数据可视化和用户交互。我成功地应用了Qt的各种模块和功能，如信号与槽机制、多线程编程以及定制绘图等，来实现高效、流畅的用户体验。

**团队合作与分享：**

我在团队中乐于分享知识和经验。我积极参与团队内的代码审查和技术分享会议，并向团队成员传授了Qt编程的最佳实践。在项目中，我也乐于接受他人的建议和意见，并与团队其他成员密切合作，确保项目按时高质量完成。

**7.跨平台开发过吗？做过跨平台开发吗？你们的应用是在不同的平台上运行的吗？**

我在之前的工作中有跨平台开发的经验。我们的应用程序主要是基于Qt开发的，因此能够轻松地在不同的平台上运行，包括Windows、Linux和 macOS。我个人负责确保我们的应用在这些不同的操作系统上都能够正常运行，并且具备良好的用户体验。针对不同平台的特性和差异，我会进行相应的调整和优化，以确保应用在每个平台上都表现出色。

**8.你们Qt版本是多少？你们从低版本到高版本迭代（5.9-5.15），迭代的过程中你做了些什么？库的升级啊谁在做？**

在这个过程中，我负责了一些关于库的升级和适配方面的工作。

##### 迭代过程中的工作内容：

1. **版本评估**：首先，我会对新版本的Qt进行详细评估，包括查看官方发布的变更说明、了解新版本的特性和改进，以及评估是否有必要升级到新版本。
2. **代码修改**：根据新版本的API和库的变化，我会检查我们应用程序中使用的Qt API，并对需要升级或调整的部分进行修改。这可能涉及到一些废弃的API的替换、新功能的使用以及旧代码的更新。
3. **库的兼容性**：我会测试我们的应用程序在新版本下的兼容性，并解决由于库变化引起的兼容性问题，确保应用能够正常运行。
4. **团队合作**：在库的升级过程中，我通常会与团队其他成员密切合作，尤其是与系统架构师和其他开发人员一起，确保库的升级不会对整体应用造成负面影响。

**9.信号和槽的原理是什么？**

在 Qt 中，信号和槽（Signals and Slots）是一种强大的机制，用于处理对象之间的通信。`connect` 函数用于建立信号和槽之间的连接关系。

##### 1. 信号和槽的基本原理：

- 信号是对象发出的事件，槽是对这些事件作出响应的函数。
- `QObject` 类是 Qt 中支持信号和槽机制的基类。
- `QObject` 类中包含了 `QObject::connect` 函数，用于建立信号和槽之间的连接。

##### 2. 信号和槽的底层实现：

- Qt 使用元对象系统（Meta-Object System）来实现信号和槽机制。
- 在编译阶段，Qt 的元对象编译器 (MOC) 会解析源文件中的信号和槽声明，并生成相应的元对象代码。
- 元对象包含了信号和槽的信息，以及对象的属性、方法等信息。
- 在运行时，当信号被触发时，会根据元对象系统查找与信号相关联的槽，并调用槽函数进行处理。

##### 3. `connect` 函数的工作原理：

- `QObject::connect` 函数用于建立信号和槽之间的连接，其参数包括信号发送者、信号、槽接收者以及槽函数。
- `connect` 函数会在元对象系统中查找信号和槽的对应关系，并建立连接。
- 当信号被发射时，会通过元对象系统找到与之相关联的槽，并调用槽函数。

**10.反问？**

**11.建议：想要看到突出点，让同事或领导认同的点，可以在这方面多说一些东西，（做股票投资展示客户端）。**





六、联汇科技（杭州滨江） 0320  12-20k

**1.自我介绍**

**2.说一下你们这个项目大概是一个怎么样的项目？讲一下你们项目是干嘛的，做什么的？（没回答好）**

​	2.1基于**自主知识产权三维图形平台**的国产BIM软件。研发**具有自主知识产权图形基础平台**，为公司其他软件产品解决产品的版权限制，降低用户成本，降低研发成本，为产品的后序发展提供更多的问题解决途径和提升空间。

**3.你觉得元对象系统是个什么东西？或者说你了解吗？大概有哪几部分组成的呢？（大致回答了）**

使用元对象系统需要满足三个条件：

- 只有QObject派生类才可以使用元对象系统特性。
- 在类声明前使用Q_OBJECT()宏来开启元对象功能。
- 使用Moc工具为每个QObject派生类提供实现代码。

元对象系统是一种用于**支持信号和槽机制**、**反射**（reflection）和**对象间通信**的特性

由以下四个部分组成：

1. **MetaObjec**t（元对象）：每个继承自 QObject 的类都有一个对应的元对象，它存储了关于该类的元信息，比如类名、信号和槽等。
2. **MOC**（Meta-Object Compiler）：MOC 是一个预处理器工具，用于解析包含 Qt 元对象系统相关特性的头文件，并生成额外的 C++ 代码来支持元对象系统的功能。
3. **信号和槽机制**（Signals and Slots）：Qt 中的信号和槽机制是基于元对象系统实现的，通过信号和槽可以实现对象间的通信，解耦对象之间的依赖关系。
4. **反射机制**（Reflection）：Qt 的元对象系统也提供了一定程度的反射支持，可以在运行时查询和操作类的属性、方法等元信息。

**4.信号和槽connect有几种方式？（回答出来了）追问：connect，信号和槽里面传参，可以传函数指针，宏定义，这两个可以传吗？（我回答可以，答案：宏定义不可以，函数指针可以，元对象系统解析不了宏定义）如果传自己定义的一个struct（结构体），在传的时候我要注意什么呢？**

1. **结构体的定义**：确保结构体在信号和槽之间的声明是可见的。最好将结构体的定义放在一个公共的头文件中，以便在信号和槽的连接处都可以访问到结构体的定义。
2. **结构体的复制**：当传递结构体时，实际上是将结构体的副本传递给了槽函数。因此，在进行结构体的传递时，会发生结构体的拷贝操作。如果结构体比较大或者包含指针等复杂数据，则可能会带来性能损耗。
3. **结构体的值类型或引用类型**：默认情况下，Qt 的信号和槽传递的参数是值类型，即会进行拷贝。如果希望避免拷贝开销，可以将结构体作为指针或引用类型传递。
4. **Q_DECLARE_METATYPE 宏**：如果要在信号和槽之间传递自定义的结构体类型，需要使用 Q_DECLARE_METATYPE 宏对结构体进行注册，以便 Qt 可以正确处理该类型的参数。
5. **线程安全**：如果涉及到不同线程之间的信号和槽传递，需要注意结构体的线程安全性，确保在不同线程之间正确地传递和处理结构体数据。

**5.多线程这块有写过吗？有哪几种方式？你觉得哪种方式好？**

1. **继承 QThread 类**：通过继承 QThread 类并重写其 run() 函数，在 run() 函数中实现需要在新线程中执行的逻辑。这是最直接和简单的多线程方式，但可能不够灵活，因为每个 QThread 对象只能运行一次。
2. **使用 QtConcurrent**：QtConcurrent 是 Qt 提供的一个模块，可以轻松实现并行计算。通过 QtConcurrent::run() 函数可以将函数或函数对象放入后台线程中执行，非常方便。
3. **使用 QThreadPool 和 QRunnable**：利用 QThreadPool 和 QRunnable 可以实现线程池，可以复用线程对象，提高效率。QRunnable 是一个虚基类，可以通过子类化 QRunnable 并实现其 run() 函数来定义任务，然后将任务提交给 QThreadPool 执行。
4. **信号槽跨线程通信**：通过信号槽机制实现跨线程通信。在 Qt 中，信号槽可以跨线程使用，通过连接信号和槽的方式实现线程间的通信，确保线程安全。
5. **使用 Qt Concurrent 异步编程**：Qt 提供了一些异步编程的支持，比如 QFuture 和 QFutureWatcher，可以方便地进行异步操作，并在操作完成后获取结果。
6. **使用 QObject 的子类**：创建一个继承自 `QObject` 的子类，将耗时操作封装在该类中的槽函数中，然后使用 `moveToThread()` 将该对象移动到新创建的线程中。

哪种方式更好取决于具体的需求和场景。一般来说，**推荐使用信号槽跨线程通信**的方式，因为它能够很好地**管理线程间的通信和同步**，避免了直接操作线程的复杂性，同时也符合 Qt 的事件驱动架构。另外，使用 QtConcurrent 等高层次的API也可以简化多线程编程，并提高代码的可读性和可维护性。

**6.TCP/IP网络你了解哪些呢？**

1. **TCP（Transmission Control Protocol）**：提供可靠的、面向连接的数据传输服务，确保数据的可靠性和顺序性，四层协议（传输层），使用时，会有一个三次握手跟四次挥手的过程。

   三次握手跟四次挥手：三次握手（Three-Way Handshake）：

   1. **客户端发送连接请求：** 客户端向服务器发送一个带有 SYN（同步序列编号）标志的数据包，表示请求建立连接。
   2. **服务器确认并回应：** 服务器收到请求后，如果同意建立连接，会发送一个带有 SYN 和 ACK 标志的数据包作为响应，表示接受连接请求。
   3. **客户端确认连接：** 客户端收到服务器的确认后，也会发送一个带有 ACK 标志的数据包给服务器，表示连接已建立。

   经过这三次握手，客户端和服务器之间就建立了可靠的连接，可以开始数据传输。

   ##### 四次挥手（Four-Way Handshake）：

   1. **发起断开连接请求：** 当客户端或服务器决定断开连接时，发起者会向另一方发送一个带有 FIN（结束）标志的数据包，表示要断开连接。
   2. **对方确认：** 接收到断开连接请求的一方会发送一个带有 ACK 标志的数据包作为确认，表示已经收到断开请求。
   3. **关闭连接：** 等到另一方不再需要连接时，会发送一个带有 FIN 标志的数据包给发起断开连接的一方，表示同意关闭连接。
   4. **最后确认：** 发起断开连接的一方收到确认后，也会发送一个带有 ACK 标志的数据包作为最后的确认，表示连接已经关闭。

   通过这四次挥手的过程，客户端和服务器完成了连接的断开，释放了双方的资源，并结束了数据传输。

2. **UDP（User Datagram Protocol）**：与 TCP 相比，UDP 是一种无连接的、不可靠的传输协议，用于传输不需要可靠性保证的数据，适用于对实时性要求较高的场景。

3. **HTTP（Hypertext Transfer Protocol）**：基于 TCP 协议，用于传输超文本数据，是万维网的数据传输协议。

4. **HTTPS（Hypertext Transfer Protocol Secure）**：是 HTTP 的安全版，采用了 SSL/TLS 协议进行加密通信。

**7.https请求有几种？post请求，参数放在哪里？postman的JSON放在哪里？(body).**

1. **GET 请求**：GET 请求是用于从服务器获取数据的请求方法，参数通常以**查询字符串**的形式附加在 URL 后面，例如：https://www.example.com/api/data?id=123。GET 请求的参数**直接暴露在 URL 中**，不适合传输敏感信息。
2. **POST 请求**：POST 请求用于向服务器提交数据，通常将数据放在**请求的消息体**中进行传输，而不像 GET 请求那样暴露在 URL 中。POST 请求的参数一般放在请求的**消息体（body）**中，而不是在 URL 中。

**8.https跟http有什么区别？s是什么呢？**

HTTPS 和 HTTP 之间的主要区别在于**安全性**和数据传输的**加密方式**：

1. **HTTP（HyperText Transfer Protocol）**：是**超文本传输协议**，用于在 Web 浏览器和 Web 服务器之间传输数据。HTTP 是一种**明文传输**的协议，数据以**纯文本形式**传输，安全性较低。
2. **HTTPS（HyperText Transfer Protocol Secure）**：是**基于 HTTP 的加密**协议，通过 **SSL**（Secure Sockets Layer）或 **TLS**（Transport Layer Security）协议对数据进行**加密传输**，从而提供了更高的安全性。S 代表 Secure，表示安全的意思。

**9.UDP有用过吗？**

在 Qt 中，你可以使用 **QUdpSocket** 类来实现 UDP 相关的网络通信功能。QUdpSocket 类提供了 UDP 套接字的功能，可以用于发送和接收 UDP 数据包。

以下是一个简单的使用 QUdpSocket 实现 UDP 通信的示例：

```
#include <QtNetwork>

// 创建 QUdpSocket 对象
QUdpSocket *udpSocket = new QUdpSocket(this);

// 绑定本地端口
udpSocket->bind(QHostAddress::Any, 1234);

// 发送 UDP 数据包
QByteArray datagram = "Hello, UDP!";
udpSocket->writeDatagram(datagram, QHostAddress::LocalHost, 1234);

// 接收 UDP 数据包
connect(udpSocket, &QUdpSocket::readyRead, this, [udpSocket](){
    while (udpSocket->hasPendingDatagrams()) {
        QByteArray datagram;
        datagram.resize(udpSocket->pendingDatagramSize());
        udpSocket->readDatagram(datagram.data(), datagram.size());
        qDebug() << "Received datagram: " << datagram;
    }
});
```

**10.多线程之间要注意什么呢？**

1. **共享数据访问**：多个线程如果需要访问共享数据，必须采取同步措施，如使用互斥锁（mutex）或信号量（semaphore）来避免数据竞争和不一致性。
2. **避免死锁**：当多个线程相互等待对方释放资源时，可能发生死锁。为避免死锁，应该避免线程持有一个锁时同时尝试获取另一个锁。
3. **线程间通信**：确保线程间通信的安全性和有效性，可以使用线程安全的队列或信号量等机制来进行线程间通信，通信方式：**共享变量，锁机制，条件变量，信号量，管道**
4. **资源管理**：确保多个线程正确管理共享资源，及时释放资源，避免内存泄漏和资源浪费。

**11.设计模式？单例模式？**

单例模式是一种**创建型**设计模式，其目的是确保类**只有一个实例**，并提供**一个全局访问点**。这对于那些需要**频繁访问同一对象实例**的情况非常有用。

**12.你们用的Qt是几？QSS的样式版本是几？你们用的Qt5.9的版本，你能做出内阴影吗？用的CSS2的技术，用CSS3就可以解决，得上Qt6去。QML可以解决。**

**13.QML了解过吗？**

​		把QSS的东西用QML去描述了，描述性语言放在前台了，后台做业务，前台做界面。

**14.数据库用过MySQL，了解一下。**

1. **QSqlDatabase**: QSqlDatabase 类表示一个数据库连接。它用于连接到数据库、执行 SQL 查询和管理数据库连接。
2. **QSqlQuery**: QSqlQuery 类用于执行 SQL 查询并处理查询结果。可以使用它执行 SELECT、INSERT、UPDATE 和 DELETE 等操作。

**15.自己重写过哪些控件？QListView，讲一下视图和模式（MVC），它里面的委托是什么概念？有没有用过，有没有重写过？着重了解一下委托的使用。**

`QListView` 中，我们通常需要提供一个**数据模型**（Model）来管理要**显示的数据**，并使用委托（Delegate）来**自定义视图**中每个条目的**外观**和**交互方式**

**委托（Delegate）** 是用于控制视图中数据项样式和交互的对象。通过委托，我们可以自定义每个数据项的外观，比如设置不同的字体、颜色、背景等，并且可以处理用户交互事件，比如鼠标点击、双击等。

##### 委托的使用：

1. **内置委托：**
   - Qt 提供了**默认的委托**来显示数据项，但通常情况下我们需要根据具体需求自定义委托。
2. **自定义委托：**
   - 我们可以通过继承 `QStyledItemDelegate` 类来自定义委托，然后重写相应的方法来实现自定义外观和交互效果。
   - 在自定义委托时，通常会重写以下方法：
     - `paint()`: 用于绘制数据项的外观。
     - `sizeHint()`: 返回数据项的大小。
     - `editorEvent()`: 处理用户的交互事件，比如鼠标点击、双击等。
     - setModelData()：它通常用于自定义代理模型（QStyledItemDelegate）中，用来将用户输入的数据传递给模型的特定项。
     - createEditor()：在自定义代理模型中，当用户需要编辑某一项数据时，会调用 `createEditor()` 函数来创建相应的编辑器部件，用户可以在这个编辑器部件中输入或选择需要修改的数据。编辑器部件通常是基于 QWidget 的子类，可以根据需要进行自定义样式和行为。
3. **在 `QListView` 中使用委托：**
   - 将自定义委托对象设置给 `QListView`，可以通过 `setItemDelegate()` 方法来指定委托对象。
   - 通过设置委托，可以实现对每个数据项的**外观和交互**进行个性化定制。

**16.Linux下做过开发吗？Linux下做过Qt吗？**

**17.对加班怎么看？**

**18.反问？**

七、杭州科工电子（西湖）0323     12-20K

 没有问技术，两个面试官稍微聊了下。



八、杭州登虹科技（西湖）0326    10-15K

​	1.自我介绍

​	**2.稍微讲一下你的项目？**

​	3.你们用到OpenGL吗？(以前没问到过)

​			OpenGL：是一种用于渲染2D、3D矢量图形的跨平台编程接口（API）。它提供了一系列用于绘制复杂图形的函数和工具，被广泛用于游戏开发、**计算机辅助设计（CAD）**、虚拟现实（VR）、科学可视化等领域。

OpenGL是一种**强大的图形渲染API**，为开发者提供了丰富的工具和功能，用于创建高性能、跨平台的图形应用程序。

​	**4.C++11，C++14代码语法熟吗？聊一下C++11某些特性的见解吗？**

​		自动类型推导（`auto`关键字），区间循环（range-based for loop），Lambda表达式，新的智能指针（`std::shared_ptr`, `std::unique_ptr`），**左值右值**，**std::thread**等

​	左值（lvalue）

- 左值是指在内存中有确定存储位置的表达式，**可以取地址**并且可以被修改。
- 具体来说，左值可以是变量、对象成员、解引用指针等，它们都有一个**确定的内存地址**。
- 通常情况下，**左值表示了一个具体的对象或变量。**
- int x = 10; *// x是一个左值，具有确定的内存地址* int* ptr = &x; *// 取x的地址，ptr是一个左值*

​    2.右值（rvalue）

- 右值是指**不能取地址**、且表达式执行后会生成临时值的表达式。
- 右值可以是字面常量、临时对象、表达式的结果等。
- 右值引用通常用于**延长右值的生命周期**，以便进行后续的操作。
- int y = 20; *// y是一个右值，20是一个字面常量右值* int z = x + y; *// x + y是一个右值，表示一个临时的结果*

**std::thread**：是 C++11 标准库中引入的一个重要组件，用于**支持多线程编程**。

​	**创建线程**： 使用 `std::thread` 可以创建新的线程，需要指定要执行的函数或可调用对象，并可以传递参数给该函数。例如：

```
#include <iostream>
#include <thread>

void threadFunction(int n) {
    std::cout << "Thread function executing. n = " << n << std::endl;
}

int main() {
    int value = 42;
    std::thread t(threadFunction, value); // 创建新线程并执行 threadFunction
    t.join(); // 等待新线程执行完毕
    return 0;
}
```

​	线程管理： 使用 `std::thread` 可以对线程进行管理，如等待线程完成（`join()`）、分离线程（`detach()`）等操作。通常情况下，需要在主线程中调用 `join()` 等待子线程执行完成，以避免出现竞态条件或资源泄漏。

​	**线程安全性**： 在多线程编程中，需要特别注意线程安全性。多个线程可能同时访问共享的资源，因此需要采取适当的同步措施来避免数据竞态和不确定行为。例如，可以使用互斥锁（`std::mutex`）来保护共享资源。

​	**移动语义**： `std::thread` 支持移动语义，允许将线程对象所有权从一个对象转移给另一个对象，从而实现线程的转移和管理。

​	**5.你做这个项目中，有没有遇到一些很难解决的问题？**

​	（讲了下小茗AI助手的问题，讲的不好，得再梳理一下）

​	6.第三方库的网络有用到吗？嵌网页怎么嵌入？

​		一些流行的第三方网络库包括：

- Boost.Asio：一个跨平台的C++网络编程库，提供了异步I/O和网络操作的支持。

- libcurl：一个用于传输数据的客户端端库，支持多种协议，如HTTP、FTP、SMTP等。

- OpenSSL：一个用于安全通信的开源加密库，支持SSL/TLS协议。

- WebSocket++：一个用于WebSocket通信的C++库，提供了WebSocket协议的实现。

- Poco C++ Libraries：一个跨平台的C++库，提供了丰富的网络和通信功能。

  **qt嵌网页**：在 Qt 中嵌入网页通常使用 Qt WebEngine 模块，该模块提供了一个基于 Chromium 的浏览器引擎，使得在 Qt 应用程序中嵌入网页变得非常简单。以下是使用 Qt WebEngine 在 Qt 应用程序中嵌入网页的基本步骤：

  **准备工作**：首先，确保你的 Qt 版本已经包含了 Qt WebEngine 模块。如果没有，你需要在安装 Qt 时选择安装 Qt WebEngine 模块，或者在你的项目文件（.pro 文件）中添加相应的模块依赖。

  **包含头文件**：在你的代码中包含 Qt WebEngine 的头文件：

  ```
  #include <QWebEngineView>
  ```

  **创建 Web 视图**：在你的应用程序中创建一个 Qt WebEngine 视图（QWebEngineView），该视图将用于显示网页内容。

  ```
  QWebEngineView *webView = new QWebEngineView(this);
  ```

  **加载网页**：使用 `load()` 方法加载指定的网页：

  ```
  webView->load(QUrl("http://www.example.com"));
  ```

  **添加到布局**：将 Web 视图添加到你的应用程序的布局中，或者直接将其作为窗口的主要内容：

  ```
  setCentralWidget(webView);
  ```

  **运行程序**：编译并运行你的 Qt 应用程序，你应该能够看到嵌入的网页在应用程序中显示出来。

7.Qt上的调试问题，windebug了解吗？如果客户软件遇到问题，怎么找问题？

​	WinDebug 是 Windows 平台上常用的调试工具之一，它与 Qt Creator 配合使用可以进行高效的调试。

​	**日志记录**：在您的软件中添加日志记录功能，记录关键操作和事件。这些日志可以帮助您追踪问题发生的原因。您可以使用 Qt 的日志库（如 qDebug、qInfo、qWarning、qCritical 等）来记录信息。

**远程调试**：如果客户的环境允许，您可以通过远程连接进行调试。通过远程桌面工具或者远程调试工具，您可以直接查看客户的环境并尝试重现问题。

**版本管理**：确保您的软件有一个明确的版本号，并且您能够在需要时快速找到对应版本的源代码。这样，即使客户报告了一个旧版本的问题，您也可以轻松地找到并解决它。

**远程日志**：如果可能的话，在客户端启用远程日志记录功能。这样，您可以从客户端收集日志，并在您的开发环境中分析日志以定位问题。

**Dump** 文件通常指的是内存转储文件（Memory Dump File），它是操作系统在发生严重错误或异常时将当前内存中的数据内容保存到磁盘上的一种文件。这个文件包含了在错误发生时内存中的所有信息，包括程序的状态、数据结构、堆栈信息等。

Dump有调试过吗？

8.多线程这块清楚吗？

1. **QThread 类**：QThread 是 Qt 提供的用于创建线程的类，它允许您创建新的线程并在其中执行任务。您可以通过继承 QThread 类并重写其 run() 方法来定义线程执行的任务。通过 QThread 类，您可以创建和管理多个线程，并且可以控制线程的启动、暂停、停止等操作。

2. **QtConcurrent 框架**：QtConcurrent 是 Qt 提供的一个高级并发框架，它简化了多线程编程的复杂性。通过 QtConcurrent，您可以使用诸如 map、filter、reduce 等高级函数来并行执行任务。QtConcurrent 还提供了线程池的支持，可以方便地管理线程的数量和资源使用情况。

3. **信号与槽机制**：Qt 的信号与槽机制是一种线程安全的通信机制，可以在不同线程之间进行异步通信。您可以将耗时的任务放在一个线程中执行，并通过信号与槽来与其他线程进行通信。这样可以避免在主线程中执行耗时任务导致界面卡顿的问题。

4. **线程安全性**：Qt 提供了一些线程安全的类和函数，如 QMutex、QReadWriteLock 等，用于在多线程环境中保护共享资源的访问，避免数据竞争和并发访问的问题。

5. **事件循环**：在 Qt 中，每个线程都有自己的事件循环，通过事件循环可以处理事件和消息。在非主线程中使用事件循环可以确保线程的响应性和可控性。

   

   **死锁**是在多线程或多进程环境中可能出现的一种情况，其中每个线程或进程都在**等待**其他线程或进程释放其所持有的**资源**，导致所有线程或进程都**无法继续执行**的状态。

   死锁发生的条件通常包括以下四个必要条件：

   1. **互斥条件**：每个资源只能被一个线程或进程占用，如果资源被占用，其他线程或进程必须等待。
   2. **请求与保持条件**：线程或进程可以持有资源并请求其他资源。在持有一些资源的同时，又请求其他资源，但无法立即满足请求时，就会发生死锁。
   3. **不可剥夺条件**：已分配给线程或进程的资源不能被强制性地剥夺，只能在使用完后自愿释放。
   4. **环路等待条件**：存在一个线程或进程的资源等待链，使得每个线程或进程都在等待下一个线程或进程释放资源，形成一个闭环。

   要解决死锁问题，通常可以采取以下方法之一：

   - **避免死锁**：通过设计算法和数据结构，以避免出现死锁的情况。例如，使用资源分配图算法来动态地分配资源，确保不会形成死锁。
   - **检测和恢复**：实现死锁检测算法来检测死锁的发生，并在检测到死锁时采取适当的措施，如回滚操作或杀死某些进程来解除死锁。
   - **避免死锁**：通过破坏死锁发生的条件之一来避免死锁。例如，可以采用资源分配策略、加锁顺序、超时等方法来破坏死锁的形成条件。
   - **死锁预防**：通过在设计阶段预防死锁的发生，如破坏死锁四个必要条件之一，来避免死锁的发生。

9.cmake和qmake？

10.平时有遇到一些难的问题？比如内存问题？

​	内存泄漏，内存溢出?

11.lambda表达式值捕获，引用捕获，了解吗？引用捕获在多线程中用到，可能会产生什么问题？

​	**值捕获（Value Capture）**：在lambda表达式中，如果使用了**外部变量**，并且这个外部变量是在lambda表达式定义时**可访问**的，那么这个外部变量的值在lambda表达式创建时就被捕获了。在lambda表达式中使用的外部变量的值将**被复制一份**，而不是直接引用外部变量本身。这意味着即使外部变量的值在lambda表达式执行之后发生了改变，lambda表达式捕获的值也不会受到影响。

**引用捕获（Reference Capture）**：对于引用捕获，lambda表达式可以**显式地使用**外部变量的引用。这样，在lambda表达式中使用的外部变量的值将**不被复制**，而是直接引用外部变量本身。这意味着在lambda表达式执行期间，外部变量的值发生改变时，lambda表达式中使用的值也会相应地改变。

1. **竞态条件**：当多个线程同时访问和修改共享的资源时，由于执行顺序不确定，可能会导致程序的最终状态依赖于线程的执行顺序，进而产生意外的结果。在使用引用捕获时，如果多个线程同时修改引用捕获的变量，就可能出现竞态条件问题，导致程序逻辑错误。

2. **数据竞争**：数据竞争是指多个线程并发访问共享内存位置，并且其中至少一个线程对这个内存位置进行了写操作，从而可能导致未定义的行为。如果在引用捕获中出现数据竞争，例如一个线程在lambda表达式中引用捕获了某个变量，并尝试对其进行写操作，而另一个线程也在同时访问或修改这个变量，就可能引发数据竞争问题。

   多线程环境下，尽量避免使用引用捕获，而是选择**值捕获**的方式来避免潜在的并发问题。

12.讲一下Qt的信号和槽你的了解？

回答了：pass.

13.你们Qt开发有没有跨平台？

pass

14.你们是用qt Designer画出来的还是用代码？

pass

15.网络编程这一块熟吗?(讲一下AI小茗助手的项目)，QNetworkAccessMangerder这个类的底层有了解过吗？

再梳理一下。

16.做界面会涉及到一些设计模式？

​	MVC跟单例，工厂。

工厂：用于创建对象的实例，而无需指定其具体的类。它提供了一个统一的接口来创建对象，但允许子类决定实例化的具体类。

#include <iostream>

// 抽象产品类
class Shape {
public:
    virtual void draw() = 0;
};

// 具体产品类：圆形
class Circle : public Shape {
public:
    void draw() override {
        std::cout << "Inside Circle::draw() method." << std::endl;
    }
};

// 具体产品类：矩形
class Rectangle : public Shape {
public:
    void draw() override {
        std::cout << "Inside Rectangle::draw() method." << std::endl;
    }
};

// 简单工厂类
class ShapeFactory {
public:
    static Shape* create_shape(const std::string& shape_type) {
        if (shape_type == "circle") {
            return new Circle();
        } else if (shape_type == "rectangle") {
            return new Rectangle();
        } else {
            throw std::invalid_argument("Unsupported shape type.");
        }
    }
};

// 客户端代码
int main() {
    // 创建圆形
    Shape* circle = ShapeFactory::create_shape("circle");
    circle->draw();

    // 创建矩形
    Shape* rectangle = ShapeFactory::create_shape("rectangle");
    rectangle->draw();
    
    delete circle; // 释放内存
    delete rectangle; // 释放内存
    
    return 0;
}

单例：用于确保一个类只有一个实例，并提供一个全局访问点让程序可以访问这个实例。这种模式通常在需要管理共享资源、控制对唯一实例的访问时使用。

讲一下懒汉模式跟饿汉模式？

- **懒汉模式**：
  - 在懒汉模式中，单例实例在**首次被请求**时才被创建。换句话说，实例在**需要**时才会被实例化。
  - 懒汉模式的优点是**节省了系统资源**，因为只有在**需要时才会创建实例**。
  - 但是懒汉模式可能存在**线程安全**性问题，需要考虑多线程环境下的实例创建问题。
- **饿汉模式**：
  - 在饿汉模式中，单例实例在**类加载时就被创建**，即在程序运行前就已经创建好了单例实例。
  - 饿汉模式的优点是实现简单，且**线程安全**，不需要担心多线程环境下的实例创建问题。
  - 但是饿汉模式可能会**浪费一些系统资源**，因为实例在启动时即被创建，无论是否会被使用。

17.Qt的打印模块有了解吗？

在Qt中，打印功能由一组打印类提供支持，其中包括：

1. `QPrinter`：表示打印机的类。它提供了与打印相关的设置和操作，如选择打印机、设置页面大小和方向、设置打印范围等。

2. `QPrintDialog`：打印对话框类，用于显示打印对话框供用户选择打印设置。它基于`QPrinter`类，可以方便地与打印机进行交互。

3. `QPrintPreviewDialog`：打印预览对话框类，用于显示打印预览界面。它也基于`QPrinter`类，可以在打印之前预览打印结果。

4. `QPrintPreviewWidget`：打印预览窗口类，用于在自定义的窗口中显示打印预览。它提供了与打印预览相关的控制和操作。

   

5. ```cpp
   #include <QApplication>
   #include <QTextEdit>
   #include <QPrintDialog>
   #include <QPrinter>
   
   int main(int argc, char *argv[])
   {
       QApplication app(argc, argv);
   
       // 创建一个文本编辑器
       QTextEdit textEdit;
       textEdit.setText("Hello, Printer!");
   
       // 创建一个打印对话框
       QPrintDialog printDialog;
   
       // 如果用户点击了打印按钮
       if (printDialog.exec() == QDialog::Accepted) {
           // 获取选定的打印机
           QPrinter *printer = printDialog.printer();
   
           // 创建一个打印机绘图设备
           QPainter painter(printer);
   
           // 开始打印操作
           textEdit.print(&painter);
       }
   
       return app.exec();
   }
   ```

18.你有参与过 产品评审吗？

19.对处理bug，解决bug会比较关注，你能多讲讲哪些比较难解决的问题？有碰到过踩内存吗？

释放掉的内存被比人占用了？有没有遇到长时间挂机突然崩溃的问题？

20.有没有开发一些小的库？

21.有想过深入学习OpenGL那种吗？

建议：不要纠结在界面，早点去学音视频方面。
