## 设计模式学习

### 前言

**1.来源：**设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。 一共有23 种设计模式。

**2.六大原则：**总原则--开闭原则 

​	2.1单一职责原则

​	2.2里氏替换原则

​	2.3依赖倒置原则

​	2.4接口隔离原则

​	2.5迪米特法则（最少知道原则）

​	2.6合成复用原则

**3.设计模式的三大类**：

​	3.1**创建型**

​		（5种）**工厂模式**、**抽象工厂模式**、**单例模式**、建造者模式、原型模式

​			记忆口诀：创工原单建抽（创公园，但见愁）

​	3.2**结构型**

​		（7种）**适配器模式**、装饰者模式、代理模式、**外观模式**、桥接模式、组合模式、享元模式

​			记忆口诀：结享外组适代装桥（姐想外租，世代装桥）

​	3.3**行为型**

​		（11种）**策略模式**、模板方法模式、**观察者模式**、迭代器模式、**责任链模式**、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式

​		记忆口诀：行状责中模访解备观策命迭（形状折中模仿，戒备观测鸣笛）



#### 注意：由于实际开发中并没有全部用到，加上要出去面试，时间比较紧迫，需要侧重点学习一些经常考察的设计模式，并不代表其它的不重要而不进行学习，后续会补充完整。（2023.10.17）

### 一、经常考察的设计模式

#### 1.单例模式

#### 2.工厂模式、

#### 3.抽象工厂模式

#### 4.观察者模式

#### 5.责任链模式

#### 6.适配器模式

#### 7.外观模式（肯德基套餐模式）

#### 8.策略模式

##### (11.27)

##### 一、概述

​		设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。

总体来说可以分为三大类：创建型模式（ Creational Patterns ）、结构型模式（ Structural Patterns ）和行为型模式（ Behavioral Patterns ）。

##### 二、创建型

##### 1.单例（Singleton）

在应用这个模式时，单例对象的类必须保证只有**一个实例**存在，整个系统只能使用**一个对象实例**。

确保一个类只**有一个实例**，并提供该实例的全局访问点。

优点：不会频繁地创建和销毁对象，浪费系统资源。

使用场景：IO 、数据库连接、Redis 连接等。

懒汉：故名思义，不到万不得已就不会去实例化类，也就是说在第一次用到类实例的时候才会去实例化，所以上边的经典方法被归为懒汉实现；

饿汉：饿了肯定要饥不择食。所以在单例类定义的时候就进行实例化。

特点：

​		1.由于要进行线程同步，所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间。

​		2.在访问量较小时，采用懒汉实现。这是以时间换空间。

Singleton.h

class Singleton
{
private:
	static Singleton *uniqueInstance;
	Singleton() ;
public:
	static Singleton *getUniqueInstance();
};

Singleton.cpp

Singleton *Singleton::uniqueInstance = nullptr; //静态成员变量类外初始化

Singleton::Singleton()
{

}

Singleton* Singleton::getUniqueInstance()
{
	if (nullptr == uniqueInstance)
	{
		uniqueInstance = new Singleton();
	}
	return uniqueInstance;
}

##### 懒汉式-线程不安全

以上实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。

这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 if (uniqueInstance == null) ，并且此时uniqueInstance 为 null，那么会有多个线程执行 uniqueInstance = new Singleton(); 语句，这将导致实例化多次 uniqueInstance。

等到用的的时候程序再创建实例对象。

优点：第一次使用实例对象时，创建对象。进程启动无负载。多个单例实例启动顺序自由控制。
缺点：复杂 



SingletonHungry.h

class SingletonHungry
{
protected:
	SingletonHungry();
private:
	static SingletonHungry* uniqueInstance;
public:
	static SingletonHungry* instance();
};

SingletonHungry.cpp

SingletonHungry*SingletonHungry::uniqueInstance = new SingletonHungry;

SingletonHungry::SingletonHungry()
{

}

SingletonHungry* SingletonHungry::instance()
{
	return uniqueInstance;
}

##### 饿汉式-线程安全

饿汉实现如上，线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。

但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。

就是说不管你将来用不用，程序启动时就创建一个唯一的实例对象。

优点：简单

缺点：可能会导致进程启动慢，且如果有多个单例类对象实例**启动顺序不确定**。

##### 线程安全的懒汉实现

**方法1：加锁的经典懒汉实现（线程安全）**

//懒汉式-线程安全
class Singleton
{
protected:
	Singleton();
private:
	static Singleton* p;
public:
	static std::mutex  mutex;
	static Singleton* initance();

};

std::mutex Singleton::mutex;
Singleton*Singleton::p = nullptr;

Singleton::Singleton()
{

}

Singleton* Singleton::initance()
{
	if (nullptr == p)
	{

​		//std::lock_guard;    //来进行自动加锁和解锁管理。

​		mutex.lock(); // 加锁 // 加锁
​		if (nullptr == p)
​		{
​			p = new Singleton();
​			

	   }
		mutex.unlock();
	 }
	 return p;
}

##### 方法2：内部静态变量的懒汉实现

在instance函数里定义一个静态的实例，也可以保证拥有唯一实例，在返回时只需要**返回其指针**就可以了。推荐这种实现方法。

//4、内部静态变量的懒汉实现
class singleton
{
protected:
	singleton() {}
public:
	static std::mutex mutex;
	static singleton* initance();
};

std::mutex singleton::mutex;
singleton* singleton::initance()
{
	mutex.lock();
	static singleton obj;
	mutex.unlock();
	return &obj;
}